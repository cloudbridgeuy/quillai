<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QuillAi Parchment WASM - Performance Benchmark</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background: #f5f7fa;
      }

      .header {
        text-align: center;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 30px;
        border-radius: 12px;
        margin-bottom: 30px;
      }

      .benchmark-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }

      .benchmark-card {
        background: white;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        border: 1px solid #e1e8ed;
      }

      .benchmark-title {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 15px;
        color: #2c3e50;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .benchmark-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-wrap: wrap;
      }

      .btn {
        background: #3498db;
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;
      }

      .btn:hover {
        background: #2980b9;
        transform: translateY(-1px);
      }
      .btn:disabled {
        background: #bdc3c7;
        cursor: not-allowed;
        transform: none;
      }
      .btn-small {
        padding: 6px 10px;
        font-size: 12px;
      }
      .btn-success {
        background: #27ae60;
      }
      .btn-success:hover {
        background: #219a52;
      }
      .btn-warning {
        background: #f39c12;
      }
      .btn-warning:hover {
        background: #d68910;
      }
      .btn-danger {
        background: #e74c3c;
      }
      .btn-danger:hover {
        background: #c0392b;
      }

      .results {
        background: #2c3e50;
        color: #ecf0f1;
        border-radius: 6px;
        padding: 15px;
        font-family: "Monaco", "Consolas", monospace;
        font-size: 12px;
        max-height: 300px;
        overflow-y: auto;
        margin-top: 15px;
      }

      .result-success {
        color: #2ecc71;
      }
      .result-warning {
        color: #f1c40f;
      }
      .result-error {
        color: #e74c3c;
      }
      .result-info {
        color: #3498db;
      }
      .result-highlight {
        color: #e67e22;
        font-weight: bold;
      }

      .metrics-dashboard {
        background: white;
        border-radius: 12px;
        padding: 20px;
        margin: 20px 0;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-top: 15px;
      }

      .metric-card {
        text-align: center;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #dee2e6;
      }

      .metric-value {
        font-size: 28px;
        font-weight: bold;
        color: #2c3e50;
        margin-bottom: 5px;
      }

      .metric-label {
        font-size: 12px;
        color: #7f8c8d;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .progress-bar {
        width: 100%;
        height: 20px;
        background: #ecf0f1;
        border-radius: 10px;
        overflow: hidden;
        margin: 10px 0;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #3498db, #2ecc71);
        width: 0%;
        transition: width 0.3s ease;
        border-radius: 10px;
      }

      .comparison-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
        background: white;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .comparison-table th {
        background: #34495e;
        color: white;
        padding: 12px;
        text-align: left;
        font-weight: 600;
      }

      .comparison-table td {
        padding: 10px 12px;
        border-bottom: 1px solid #dee2e6;
      }

      .comparison-table tr:nth-child(even) {
        background: #f8f9fa;
      }

      .status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .status-ready {
        background: #95a5a6;
      }
      .status-running {
        background: #f39c12;
        animation: pulse 1s infinite;
      }
      .status-success {
        background: #27ae60;
      }
      .status-error {
        background: #e74c3c;
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      .chart-container {
        width: 100%;
        height: 200px;
        background: #f8f9fa;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #7f8c8d;
        font-style: italic;
        margin: 15px 0;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>ü¶Ä QuillAi Parchment WASM Performance Benchmark</h1>
      <p>
        Comprehensive performance testing suite for Rust/WebAssembly text
        processing
      </p>
      <p>
        <strong>Bundle Size:</strong> ~28KB ‚Ä¢ <strong>Dependencies:</strong> 3
        core only ‚Ä¢ <strong>Target:</strong> Native Performance
      </p>
    </div>

    <!-- Live Metrics Dashboard -->
    <div class="metrics-dashboard">
      <h2>üìä Live Performance Metrics</h2>
      <div class="metrics-grid">
        <div class="metric-card">
          <div class="metric-value" id="totalOperations">0</div>
          <div class="metric-label">Total Operations</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="avgOperationTime">0ms</div>
          <div class="metric-label">Avg Operation Time</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="operationsPerSecond">0</div>
          <div class="metric-label">Operations/Second</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="memoryUsage">N/A</div>
          <div class="metric-label">Memory Usage</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="wasmLoadTime">N/A</div>
          <div class="metric-label">WASM Load Time</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="activeBenchmarks">0</div>
          <div class="metric-label">Active Benchmarks</div>
        </div>
      </div>
    </div>

    <!-- Benchmark Tests -->
    <div class="benchmark-grid">
      <!-- TextBlot Performance -->
      <div class="benchmark-card">
        <div class="benchmark-title">
          <span
            class="status-indicator status-ready"
            id="textblot-status"
          ></span>
          üìù TextBlot Performance
        </div>
        <div class="benchmark-controls">
          <button class="btn btn-small" id="textblot-basic" disabled>
            Basic (1K ops)
          </button>
          <button class="btn btn-small" id="textblot-intensive" disabled>
            Intensive (10K ops)
          </button>
          <button class="btn btn-small" id="textblot-unicode" disabled>
            Unicode Test
          </button>
          <button
            class="btn btn-small btn-warning"
            id="textblot-stress"
            disabled
          >
            Stress (50K ops)
          </button>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="textblot-progress"></div>
        </div>
        <div class="results" id="textblot-results">
          Ready to test TextBlot performance...
        </div>
      </div>

      <!-- ScrollBlot Performance -->
      <div class="benchmark-card">
        <div class="benchmark-title">
          <span
            class="status-indicator status-ready"
            id="scrollblot-status"
          ></span>
          üìÑ ScrollBlot Performance
        </div>
        <div class="benchmark-controls">
          <button class="btn btn-small" id="scrollblot-basic" disabled>
            Basic (100 paragraphs)
          </button>
          <button class="btn btn-small" id="scrollblot-large" disabled>
            Large Doc (1K paragraphs)
          </button>
          <button class="btn btn-small" id="scrollblot-complex" disabled>
            Complex Operations
          </button>
          <button
            class="btn btn-small btn-warning"
            id="scrollblot-stress"
            disabled
          >
            Stress (5K paragraphs)
          </button>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="scrollblot-progress"></div>
        </div>
        <div class="results" id="scrollblot-results">
          Ready to test ScrollBlot performance...
        </div>
      </div>

      <!-- Memory Management -->
      <div class="benchmark-card">
        <div class="benchmark-title">
          <span class="status-indicator status-ready" id="memory-status"></span>
          üß† Memory Management
        </div>
        <div class="benchmark-controls">
          <button class="btn btn-small" id="memory-basic" disabled>
            Basic Lifecycle
          </button>
          <button class="btn btn-small" id="memory-leak" disabled>
            Leak Detection
          </button>
          <button class="btn btn-small" id="memory-gc" disabled>
            GC Stress Test
          </button>
          <button class="btn btn-small btn-danger" id="memory-extreme" disabled>
            Extreme Test
          </button>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="memory-progress"></div>
        </div>
        <div class="results" id="memory-results">
          Ready to test memory management...
        </div>
      </div>

      <!-- DOM Integration -->
      <div class="benchmark-card">
        <div class="benchmark-title">
          <span class="status-indicator status-ready" id="dom-status"></span>
          üåê DOM Integration
        </div>
        <div class="benchmark-controls">
          <button class="btn btn-small" id="dom-basic" disabled>
            Basic DOM Ops
          </button>
          <button class="btn btn-small" id="dom-manipulation" disabled>
            DOM Manipulation
          </button>
          <button class="btn btn-small" id="dom-events" disabled>
            Event Handling
          </button>
          <button class="btn btn-small btn-warning" id="dom-stress" disabled>
            DOM Stress Test
          </button>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="dom-progress"></div>
        </div>
        <div class="results" id="dom-results">
          Ready to test DOM integration...
        </div>
      </div>

      <!-- Comparison Benchmarks -->
      <div class="benchmark-card">
        <div class="benchmark-title">
          <span
            class="status-indicator status-ready"
            id="comparison-status"
          ></span>
          ‚öñÔ∏è Performance Comparison
        </div>
        <div class="benchmark-controls">
          <button class="btn btn-small" id="comparison-native" disabled>
            vs Native JS
          </button>
          <button class="btn btn-small" id="comparison-baseline" disabled>
            WASM Baseline
          </button>
          <button class="btn btn-small" id="comparison-complex" disabled>
            Complex Comparison
          </button>
          <button
            class="btn btn-small btn-success"
            id="comparison-report"
            disabled
          >
            Generate Report
          </button>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="comparison-progress"></div>
        </div>
        <div class="results" id="comparison-results">
          Ready for performance comparisons...
        </div>
      </div>

      <!-- Real-world Scenarios -->
      <div class="benchmark-card">
        <div class="benchmark-title">
          <span
            class="status-indicator status-ready"
            id="realworld-status"
          ></span>
          üéØ Real-world Scenarios
        </div>
        <div class="benchmark-controls">
          <button class="btn btn-small" id="realworld-typing" disabled>
            Typing Simulation
          </button>
          <button class="btn btn-small" id="realworld-editing" disabled>
            Document Editing
          </button>
          <button class="btn btn-small" id="realworld-collaboration" disabled>
            Multi-user Sim
          </button>
          <button
            class="btn btn-small btn-success"
            id="realworld-suite"
            disabled
          >
            Full Suite
          </button>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="realworld-progress"></div>
        </div>
        <div class="results" id="realworld-results">
          Ready for real-world scenario testing...
        </div>
      </div>
    </div>

    <!-- Master Controls -->
    <div class="metrics-dashboard">
      <h2>üéÆ Master Controls</h2>
      <div
        style="display: flex; gap: 15px; flex-wrap: wrap; align-items: center"
      >
        <button class="btn btn-success" id="runAllBasic" disabled>
          üöÄ Run All Basic Tests
        </button>
        <button class="btn btn-warning" id="runAllIntensive" disabled>
          ‚ö° Run All Intensive Tests
        </button>
        <button class="btn btn-danger" id="runAllStress" disabled>
          üî• Run All Stress Tests
        </button>
        <button class="btn" id="clearAllResults" disabled>
          üßπ Clear All Results
        </button>
        <button class="btn" id="exportResults" disabled>
          üìä Export Results
        </button>
      </div>
    </div>

    <!-- Results Summary Table -->
    <div class="metrics-dashboard">
      <h2>üìà Results Summary</h2>
      <table class="comparison-table">
        <thead>
          <tr>
            <th>Test Category</th>
            <th>Operations</th>
            <th>Avg Time (ms)</th>
            <th>Ops/Sec</th>
            <th>Memory Impact</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody id="summaryTableBody">
          <tr>
            <td
              colspan="6"
              style="text-align: center; color: #7f8c8d; font-style: italic"
            >
              Run benchmarks to see results...
            </td>
          </tr>
        </tbody>
      </table>
    </div>

    <script type="module">
      let wasmModule;
      let wasmLoadStartTime;
      let globalStats = {
        totalOperations: 0,
        totalTime: 0,
        memoryBaseline: 0,
        testResults: new Map(),
      };

      async function initializeWasm() {
        try {
          wasmLoadStartTime = performance.now();
          updateStatus("Loading WASM module...");

          wasmModule = await import("../pkg/quillai_parchment.js");
          await wasmModule.default();
          wasmModule.init_panic_hook();

          const loadTime = performance.now() - wasmLoadStartTime;
          document.getElementById("wasmLoadTime").textContent =
            `${loadTime.toFixed(1)}ms`;

          if (performance.memory) {
            globalStats.memoryBaseline = performance.memory.usedJSHeapSize;
          }

          updateStatus("WASM loaded successfully");
          enableAllControls();
          updateGlobalStats();

          log(
            "textblot-results",
            "‚úÖ WASM module initialized successfully",
            "success",
          );
          setStatus("textblot-status", "ready");
        } catch (error) {
          updateStatus(`Error: ${error.message}`);
          log(
            "textblot-results",
            `‚ùå Failed to initialize WASM: ${error}`,
            "error",
          );
          setStatus("textblot-status", "error");
        }
      }

      function enableAllControls() {
        document
          .querySelectorAll("button")
          .forEach((btn) => (btn.disabled = false));
        document.querySelectorAll(".status-indicator").forEach((indicator) => {
          if (indicator.classList.contains("status-ready")) {
            // Keep ready status
          }
        });
      }

      function updateStatus(message) {
        console.log(`[Status] ${message}`);
      }

      function setStatus(elementId, status) {
        const element = document.getElementById(elementId);
        element.className = `status-indicator status-${status}`;
      }

      function updateProgress(elementId, percent) {
        document.getElementById(elementId).style.width = `${percent}%`;
      }

      function log(containerId, message, type = "info") {
        const container = document.getElementById(containerId);
        const timestamp = new Date().toLocaleTimeString();
        const className = `result-${type}`;

        container.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
        container.scrollTop = container.scrollHeight;
      }

      function updateGlobalStats() {
        document.getElementById("totalOperations").textContent =
          globalStats.totalOperations.toLocaleString();

        const avgTime =
          globalStats.totalOperations > 0
            ? (globalStats.totalTime / globalStats.totalOperations).toFixed(4)
            : "0";
        document.getElementById("avgOperationTime").textContent =
          `${avgTime}ms`;

        const opsPerSec =
          globalStats.totalTime > 0
            ? Math.round(
                (globalStats.totalOperations * 1000) / globalStats.totalTime,
              )
            : 0;
        document.getElementById("operationsPerSecond").textContent =
          opsPerSec.toLocaleString();

        if (performance.memory) {
          const currentMemory = performance.memory.usedJSHeapSize;
          const memoryDiff = currentMemory - globalStats.memoryBaseline;
          const memoryMB = (currentMemory / 1024 / 1024).toFixed(1);
          document.getElementById("memoryUsage").textContent = `${memoryMB}MB`;
        }

        const activeBenchmarks =
          document.querySelectorAll(".status-running").length;
        document.getElementById("activeBenchmarks").textContent =
          activeBenchmarks;
      }

      function measureOperation(name, operation, iterations = 1) {
        const start = performance.now();
        const result = operation();
        const end = performance.now();
        const duration = end - start;

        globalStats.totalOperations += iterations;
        globalStats.totalTime += duration;

        updateGlobalStats();
        return { result, duration };
      }

      function updateSummaryTable(
        category,
        operations,
        avgTime,
        opsPerSec,
        memoryImpact,
        status,
      ) {
        const tbody = document.getElementById("summaryTableBody");

        // Remove "no results" row if it exists
        if (
          tbody.children.length === 1 &&
          tbody.children[0].children.length === 1
        ) {
          tbody.innerHTML = "";
        }

        // Check if category already exists
        let row = Array.from(tbody.children).find(
          (row) => row.children[0].textContent === category,
        );

        if (!row) {
          row = tbody.insertRow();
          row.innerHTML = `
                    <td>${category}</td>
                    <td>${operations.toLocaleString()}</td>
                    <td>${avgTime.toFixed(4)}</td>
                    <td>${opsPerSec.toLocaleString()}</td>
                    <td>${memoryImpact}</td>
                    <td><span class="status-indicator status-${status}"></span>${status}</td>
                `;
        } else {
          row.children[1].textContent = operations.toLocaleString();
          row.children[2].textContent = avgTime.toFixed(4);
          row.children[3].textContent = opsPerSec.toLocaleString();
          row.children[4].textContent = memoryImpact;
          row.children[5].innerHTML = `<span class="status-indicator status-${status}"></span>${status}`;
        }
      }

      // TextBlot Performance Tests
      document
        .getElementById("textblot-basic")
        .addEventListener("click", async () => {
          setStatus("textblot-status", "running");
          updateProgress("textblot-progress", 0);

          try {
            log(
              "textblot-results",
              "üöÄ Starting TextBlot basic performance test (1K operations)...",
              "info",
            );

            const iterations = 1000;
            const results = [];

            for (let i = 0; i < iterations; i++) {
              const { duration } = measureOperation("TextBlot Basic", () => {
                const blot = new wasmModule.TextBlot(`Performance test ${i}`);
                blot.insert_at(0, "üî• ");
                blot.delete_at(blot.length() - 1, 1);
                const value = blot.value;
                blot.free();
                return value;
              });

              results.push(duration);

              if (i % 100 === 0) {
                updateProgress("textblot-progress", (i / iterations) * 100);
                await new Promise((resolve) => setTimeout(resolve, 1));
              }
            }

            updateProgress("textblot-progress", 100);

            const avgTime = results.reduce((a, b) => a + b) / results.length;
            const totalTime = results.reduce((a, b) => a + b);
            const opsPerSec = Math.round((iterations * 1000) / totalTime);

            log(
              "textblot-results",
              `‚úÖ Basic test completed: ${avgTime.toFixed(4)}ms avg, ${opsPerSec} ops/sec`,
              "success",
            );
            updateSummaryTable(
              "TextBlot Basic",
              iterations,
              avgTime,
              opsPerSec,
              "Minimal",
              "success",
            );

            setStatus("textblot-status", "success");
          } catch (e) {
            log("textblot-results", `‚ùå Basic test error: ${e}`, "error");
            setStatus("textblot-status", "error");
          }
        });

      document
        .getElementById("textblot-intensive")
        .addEventListener("click", async () => {
          setStatus("textblot-status", "running");
          updateProgress("textblot-progress", 0);

          try {
            log(
              "textblot-results",
              "‚ö° Starting TextBlot intensive test (10K operations)...",
              "warning",
            );

            const iterations = 10000;
            const startTime = performance.now();
            const blots = [];

            // Create phase
            for (let i = 0; i < iterations; i++) {
              const blot = new wasmModule.TextBlot(
                `Intensive test ${i} with longer content for realistic testing`,
              );
              blot.insert_at(0, `${i % 10} `);
              blot.delete_at(blot.length() - 5, 2);
              blots.push(blot);

              if (i % 1000 === 0) {
                updateProgress("textblot-progress", (i / iterations) * 50);
                await new Promise((resolve) => setTimeout(resolve, 1));
              }
            }

            // Manipulation phase
            for (let i = 0; i < blots.length; i++) {
              blots[i].insert_at(5, " MODIFIED ");
              if (blots[i].length() > 50) {
                blots[i].delete_at(20, 10);
              }

              if (i % 1000 === 0) {
                updateProgress("textblot-progress", 50 + (i / iterations) * 30);
                await new Promise((resolve) => setTimeout(resolve, 1));
              }
            }

            // Cleanup phase
            for (let i = 0; i < blots.length; i++) {
              blots[i].free();

              if (i % 1000 === 0) {
                updateProgress("textblot-progress", 80 + (i / iterations) * 20);
                await new Promise((resolve) => setTimeout(resolve, 1));
              }
            }

            const endTime = performance.now();
            const totalTime = endTime - startTime;
            const avgTime = totalTime / (iterations * 3); // 3 operations per blot
            const opsPerSec = Math.round((iterations * 3 * 1000) / totalTime);

            updateProgress("textblot-progress", 100);

            globalStats.totalOperations += iterations * 3;
            globalStats.totalTime += totalTime;
            updateGlobalStats();

            log(
              "textblot-results",
              `‚úÖ Intensive test completed: ${totalTime.toFixed(2)}ms total, ${avgTime.toFixed(4)}ms avg`,
              "success",
            );
            log(
              "textblot-results",
              `üìä Performance: ${opsPerSec.toLocaleString()} operations/second`,
              "highlight",
            );
            updateSummaryTable(
              "TextBlot Intensive",
              iterations * 3,
              avgTime,
              opsPerSec,
              "Low",
              "success",
            );

            setStatus("textblot-status", "success");
          } catch (e) {
            log("textblot-results", `‚ùå Intensive test error: ${e}`, "error");
            setStatus("textblot-status", "error");
          }
        });

      document
        .getElementById("textblot-unicode")
        .addEventListener("click", async () => {
          setStatus("textblot-status", "running");
          updateProgress("textblot-progress", 0);

          try {
            log(
              "textblot-results",
              "üåç Starting Unicode and emoji performance test...",
              "info",
            );

            const unicodeTexts = [
              "ü¶Ä Rust WebAssembly üöÄ",
              "ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ÿßŸÑŸÜÿµ ÿßÿÆÿ™ÿ®ÿßÿ±",
              "‰∏≠ÊñáÊµãËØïÂÜÖÂÆπ",
              "–¢–µ—Å—Ç –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ",
              "üéâüéäüéàüéÅüéÇüç∞üé≠üé™üé®üé¨üéÆüéØ",
              "ŒïŒªŒªŒ∑ŒΩŒπŒ∫œå Œ∫ŒµŒØŒºŒµŒΩŒø Œ¥ŒøŒ∫ŒπŒºŒÆœÇ",
              "‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§£ ‡§∏‡§æ‡§Æ‡§ó‡•ç‡§∞‡•Ä",
              "Êó•Êú¨Ë™û„ÅÆ„ÉÜ„Çπ„Éà„Ç≥„É≥„ÉÜ„É≥„ÉÑ",
              "üåüüí´‚≠ê‚ú®üåô‚òÄÔ∏èüåàü¶Ñüå∏üå∫üåªüå∑",
              "◊¢◊ë◊®◊ô◊™ ◊ò◊ß◊°◊ò ◊û◊ë◊ó◊ü",
            ];

            const iterations = 500;
            const results = [];

            for (let i = 0; i < iterations; i++) {
              const text = unicodeTexts[i % unicodeTexts.length];

              const { duration } = measureOperation("Unicode Test", () => {
                const blot = new wasmModule.TextBlot(text);
                blot.insert_at(0, "üî• ");
                blot.insert_at(blot.length(), " üî•");
                const split = blot.split(blot.length() / 2);
                const result = blot.value + split.value;
                blot.free();
                split.free();
                return result;
              });

              results.push(duration);
              updateProgress("textblot-progress", (i / iterations) * 100);

              if (i % 50 === 0) {
                await new Promise((resolve) => setTimeout(resolve, 1));
              }
            }

            const avgTime = results.reduce((a, b) => a + b) / results.length;
            const totalTime = results.reduce((a, b) => a + b);
            const opsPerSec = Math.round((iterations * 1000) / totalTime);

            log(
              "textblot-results",
              `‚úÖ Unicode test completed: ${avgTime.toFixed(4)}ms avg`,
              "success",
            );
            log(
              "textblot-results",
              `üåç Tested with 10 different languages and emoji sets`,
              "info",
            );
            updateSummaryTable(
              "TextBlot Unicode",
              iterations,
              avgTime,
              opsPerSec,
              "Minimal",
              "success",
            );

            setStatus("textblot-status", "success");
          } catch (e) {
            log("textblot-results", `‚ùå Unicode test error: ${e}`, "error");
            setStatus("textblot-status", "error");
          }
        });

      document
        .getElementById("textblot-stress")
        .addEventListener("click", async () => {
          setStatus("textblot-status", "running");
          updateProgress("textblot-progress", 0);

          try {
            log(
              "textblot-results",
              "üî• Starting TextBlot stress test (50K operations)...",
              "warning",
            );

            const iterations = 50000;
            const startTime = performance.now();
            const startMemory = performance.memory
              ? performance.memory.usedJSHeapSize
              : 0;

            // Batch processing for better performance measurement
            const batchSize = 1000;
            const batches = Math.ceil(iterations / batchSize);

            for (let batch = 0; batch < batches; batch++) {
              const batchStart = performance.now();
              const blots = [];

              // Create batch
              for (
                let i = 0;
                i < batchSize && batch * batchSize + i < iterations;
                i++
              ) {
                const blot = new wasmModule.TextBlot(
                  `Stress test ${batch * batchSize + i} with substantial content for memory and performance testing under extreme conditions`,
                );
                blots.push(blot);
              }

              // Manipulate batch
              blots.forEach((blot, i) => {
                blot.insert_at(0, `${i} `);
                blot.insert_at(blot.length(), ` ${i}`);
                if (blot.length() > 100) {
                  blot.delete_at(50, 20);
                }
                if (i % 10 === 0 && blot.length() > 50) {
                  const split = blot.split(blot.length() / 2);
                  split.free();
                }
              });

              // Cleanup batch
              blots.forEach((blot) => blot.free());

              const batchTime = performance.now() - batchStart;
              const progress = ((batch + 1) / batches) * 100;
              updateProgress("textblot-progress", progress);

              if (batch % 10 === 0) {
                log(
                  "textblot-results",
                  `üìä Batch ${batch + 1}/${batches} completed in ${batchTime.toFixed(2)}ms`,
                  "info",
                );
                await new Promise((resolve) => setTimeout(resolve, 1));
              }
            }

            const endTime = performance.now();
            const endMemory = performance.memory
              ? performance.memory.usedJSHeapSize
              : 0;
            const totalTime = endTime - startTime;
            const avgTime = totalTime / iterations;
            const opsPerSec = Math.round((iterations * 1000) / totalTime);
            const memoryDiff = endMemory - startMemory;

            globalStats.totalOperations += iterations;
            globalStats.totalTime += totalTime;
            updateGlobalStats();

            log("textblot-results", `üî• STRESS TEST COMPLETED!`, "highlight");
            log(
              "textblot-results",
              `üìä ${iterations.toLocaleString()} operations in ${totalTime.toFixed(2)}ms`,
              "success",
            );
            log(
              "textblot-results",
              `‚ö° Average: ${avgTime.toFixed(6)}ms per operation`,
              "success",
            );
            log(
              "textblot-results",
              `üöÄ Performance: ${opsPerSec.toLocaleString()} ops/sec`,
              "highlight",
            );
            log(
              "textblot-results",
              `üß† Memory impact: ${(memoryDiff / 1024 / 1024).toFixed(2)}MB`,
              "info",
            );

            updateSummaryTable(
              "TextBlot Stress",
              iterations,
              avgTime,
              opsPerSec,
              `${(memoryDiff / 1024 / 1024).toFixed(1)}MB`,
              "success",
            );

            setStatus("textblot-status", "success");
          } catch (e) {
            log("textblot-results", `‚ùå Stress test error: ${e}`, "error");
            setStatus("textblot-status", "error");
          }
        });

      // ScrollBlot Performance Tests
      document
        .getElementById("scrollblot-basic")
        .addEventListener("click", async () => {
          setStatus("scrollblot-status", "running");
          updateProgress("scrollblot-progress", 0);

          try {
            log(
              "scrollblot-results",
              "üìÑ Starting ScrollBlot basic test (100 paragraphs)...",
              "info",
            );

            const { duration } = measureOperation("ScrollBlot Basic", () => {
              const scroll = new wasmModule.ScrollBlot();

              for (let i = 0; i < 100; i++) {
                scroll.append_text(
                  `Paragraph ${i + 1}: This is a test paragraph with sufficient content to test realistic document operations and performance characteristics.`,
                );
                updateProgress("scrollblot-progress", (i / 100) * 100);
              }

              const stats = {
                children: scroll.children_count(),
                textContent: scroll.text_content(),
                isEmpty: scroll.is_empty(),
              };

              scroll.free();
              return stats;
            });

            const opsPerSec = Math.round((100 * 1000) / duration);

            log(
              "scrollblot-results",
              `‚úÖ Basic test completed: ${duration.toFixed(2)}ms for 100 paragraphs`,
              "success",
            );
            log(
              "scrollblot-results",
              `üìä Performance: ${opsPerSec} paragraphs/second`,
              "highlight",
            );
            updateSummaryTable(
              "ScrollBlot Basic",
              100,
              duration / 100,
              opsPerSec,
              "Low",
              "success",
            );

           setStatus("scrollblot-status", "success");
         } catch (e) {
           log("scrollblot-results", `‚ùå Basic test error: ${e}`, "error");
           setStatus("scrollblot-status", "error");
         }
       });

       document
         .getElementById("scrollblot-large")
         .addEventListener("click", async () => {
           setStatus("scrollblot-status", "running");
           updateProgress("scrollblot-progress", 0);

           try {
             log("scrollblot-results", "üìÑ Starting large document test (1K paragraphs)...", "warning");

             const startTime = performance.now();
             const scroll = new wasmModule.ScrollBlot();

             for (let i = 0; i < 1000; i++) {
               scroll.append_text(
                 `Large document paragraph ${i + 1}: This is substantial content for testing large document performance with realistic text lengths and complexity.`
               );
               
               if (i % 100 === 0) {
                 updateProgress("scrollblot-progress", (i / 1000) * 100);
                 await new Promise(resolve => setTimeout(resolve, 1));
               }
             }

             const stats = scroll.get_statistics();
             const endTime = performance.now();
             const duration = endTime - startTime;

             scroll.free();

             globalStats.totalOperations += 1000;
             globalStats.totalTime += duration;
             updateGlobalStats();

             log("scrollblot-results", `‚úÖ Large document test completed: ${duration.toFixed(2)}ms`, "success");
             log("scrollblot-results", `üìä Document stats: ${stats.words} words, ${stats.paragraphs} paragraphs`, "highlight");
             updateSummaryTable("ScrollBlot Large", 1000, duration / 1000, Math.round((1000 * 1000) / duration), "High", "success");
             setStatus("scrollblot-status", "success");
           } catch (e) {
             log("scrollblot-results", `‚ùå Large document test error: ${e}`, "error");
             setStatus("scrollblot-status", "error");
           }
         });

       document
         .getElementById("scrollblot-complex")
         .addEventListener("click", async () => {
           setStatus("scrollblot-status", "running");
           updateProgress("scrollblot-progress", 0);

           try {
             log("scrollblot-results", "üîß Starting complex operations test...", "info");

             const scroll = new wasmModule.ScrollBlot();
             const operations = [];

             // Build document
             for (let i = 0; i < 50; i++) {
               scroll.append_text(`Complex paragraph ${i} with searchable content and various operations.`);
               updateProgress("scrollblot-progress", (i / 50) * 30);
             }

             // Perform complex operations
             const startTime = performance.now();
             
             operations.push(scroll.get_statistics());
             operations.push(scroll.find_text("searchable", false));
             operations.push(scroll.replace_all("Complex", "Modified", false));
             operations.push(scroll.word_count());
             operations.push(scroll.character_count(true));
             operations.push(scroll.paragraph_count());

             updateProgress("scrollblot-progress", 80);

             const endTime = performance.now();
             const duration = endTime - startTime;

             scroll.free();

             globalStats.totalOperations += operations.length;
             globalStats.totalTime += duration;
             updateGlobalStats();

             updateProgress("scrollblot-progress", 100);

             log("scrollblot-results", `‚úÖ Complex operations completed: ${duration.toFixed(2)}ms`, "success");
             log("scrollblot-results", `üìä Performed ${operations.length} complex operations`, "highlight");
             updateSummaryTable("ScrollBlot Complex", operations.length, duration / operations.length, 
                               Math.round((operations.length * 1000) / duration), "Medium", "success");
             setStatus("scrollblot-status", "success");
           } catch (e) {
             log("scrollblot-results", `‚ùå Complex operations test error: ${e}`, "error");
             setStatus("scrollblot-status", "error");
           }
         });

        document
          .getElementById("scrollblot-stress")
          .addEventListener("click", async () => {
            setStatus("scrollblot-status", "running");
            updateProgress("scrollblot-progress", 0);

            // Add timeout protection
            const timeoutId = setTimeout(() => {
              log("scrollblot-results", "‚è∞ Test timed out after 30 seconds", "error");
              setStatus("scrollblot-status", "error");
            }, 30000);

            try {
              log("scrollblot-results", "üî• Starting ScrollBlot stress test (5K paragraphs)...", "warning");

              const startTime = performance.now();
              const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
              const scroll = new wasmModule.ScrollBlot();
              // Create massive document with more frequent yielding
              for (let i = 0; i < 5000; i++) {
                scroll.append_text(
                  `Stress test paragraph ${i + 1}: This is extensive content designed to test the limits of document processing performance and memory management under extreme conditions with substantial text content.`
                );
                
                // Yield more frequently to prevent blocking
                if (i % 100 === 0) {
                  updateProgress("scrollblot-progress", (i / 5000) * 70);
                  await new Promise(resolve => setTimeout(resolve, 1));
                }
              }

              updateProgress("scrollblot-progress", 75);
              await new Promise(resolve => setTimeout(resolve, 10));

              // Perform stress operations with yielding
              log("scrollblot-results", "üìä Getting statistics...", "info");
              const stats = scroll.get_statistics();
              
              updateProgress("scrollblot-progress", 85);
              await new Promise(resolve => setTimeout(resolve, 10));
              
              log("scrollblot-results", "üîç Finding text matches...", "info");
              const matches = scroll.find_text("Stress", false);
              
              updateProgress("scrollblot-progress", 95);
              await new Promise(resolve => setTimeout(resolve, 10));
              
              log("scrollblot-results", "üîÑ Performing text replacement...", "info");
              scroll.replace_all("Stress", "EXTREME", false);
             const endTime = performance.now();
             const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
             const duration = endTime - startTime;
             const memoryDiff = endMemory - startMemory;

              scroll.free();

              clearTimeout(timeoutId);

              globalStats.totalOperations += 5000;
              globalStats.totalTime += duration;
              updateGlobalStats();

              updateProgress("scrollblot-progress", 100);

              log("scrollblot-results", `üî• SCROLLBLOT STRESS TEST COMPLETED!`, "highlight");
              log("scrollblot-results", `üìä 5,000 paragraphs processed in ${duration.toFixed(2)}ms`, "success");
              log("scrollblot-results", `üìà Final stats: ${stats.words} words, ${stats.characters} characters`, "success");
              log("scrollblot-results", `üß† Memory impact: ${(memoryDiff / 1024 / 1024).toFixed(2)}MB`, "info");
              log("scrollblot-results", `üîç Found ${matches.length} text matches`, "info");
              updateSummaryTable("ScrollBlot Stress", 5000, duration / 5000, Math.round((5000 * 1000) / duration), 
                                `${(memoryDiff / 1024 / 1024).toFixed(1)}MB`, "success");
              setStatus("scrollblot-status", "success");
            } catch (e) {
              clearTimeout(timeoutId);
              log("scrollblot-results", `‚ùå ScrollBlot stress test error: ${e}`, "error");
              setStatus("scrollblot-status", "error");
            }
          });      // Memory Management Tests
      document
        .getElementById("memory-basic")
        .addEventListener("click", async () => {
          setStatus("memory-status", "running");
          updateProgress("memory-progress", 0);

          try {
            log(
              "memory-results",
              "üß† Starting basic memory lifecycle test...",
              "info",
            );

            const iterations = 1000;
            const memorySnapshots = [];

            if (performance.memory) {
              memorySnapshots.push(performance.memory.usedJSHeapSize);
            }

            // Create objects
            const objects = [];
            for (let i = 0; i < iterations; i++) {
              if (i % 2 === 0) {
                objects.push(new wasmModule.TextBlot(`Memory test ${i}`));
              } else {
                objects.push(new wasmModule.ScrollBlot());
              }

              if (i % 100 === 0) {
                updateProgress("memory-progress", (i / iterations) * 50);
                if (performance.memory) {
                  memorySnapshots.push(performance.memory.usedJSHeapSize);
                }
                await new Promise((resolve) => setTimeout(resolve, 1));
              }
            }

            if (performance.memory) {
              memorySnapshots.push(performance.memory.usedJSHeapSize);
            }

            // Free objects
            objects.forEach((obj, i) => {
              obj.free();
              if (i % 100 === 0) {
                updateProgress("memory-progress", 50 + (i / iterations) * 50);
              }
            });

            updateProgress("memory-progress", 100);

            if (performance.memory) {
              memorySnapshots.push(performance.memory.usedJSHeapSize);

              const initial = memorySnapshots[0];
              const peak = Math.max(...memorySnapshots);
              const final = memorySnapshots[memorySnapshots.length - 1];

              log(
                "memory-results",
                `‚úÖ Memory lifecycle test completed`,
                "success",
              );
              log(
                "memory-results",
                `üìä Initial: ${(initial / 1024 / 1024).toFixed(2)}MB`,
                "info",
              );
              log(
                "memory-results",
                `üìà Peak: ${(peak / 1024 / 1024).toFixed(2)}MB (+${((peak - initial) / 1024 / 1024).toFixed(2)}MB)`,
                "info",
              );
              log(
                "memory-results",
                `üìâ Final: ${(final / 1024 / 1024).toFixed(2)}MB (${final <= initial + 1024 * 1024 ? "GOOD" : "POTENTIAL LEAK"})`,
                final <= initial + 1024 * 1024 ? "success" : "warning",
              );

              updateSummaryTable(
                "Memory Basic",
                iterations,
                0,
                0,
                `${((peak - initial) / 1024 / 1024).toFixed(1)}MB peak`,
                final <= initial + 1024 * 1024 ? "success" : "warning",
              );
            } else {
              log(
                "memory-results",
                `‚úÖ Memory test completed (detailed metrics unavailable)`,
                "success",
              );
              updateSummaryTable(
                "Memory Basic",
                iterations,
                0,
                0,
                "N/A",
                "success",
              );
            }

            globalStats.totalOperations += iterations;
            updateGlobalStats();

           setStatus("memory-status", "success");
         } catch (e) {
           log("memory-results", `‚ùå Memory test error: ${e}`, "error");
           setStatus("memory-status", "error");
         }
       });

       document
         .getElementById("memory-leak")
         .addEventListener("click", async () => {
           setStatus("memory-status", "running");
           updateProgress("memory-progress", 0);

           try {
             log("memory-results", "üîç Starting memory leak detection test...", "info");

             const iterations = 500;
             const memorySnapshots = [];

             for (let cycle = 0; cycle < 5; cycle++) {
               if (performance.memory) {
                 memorySnapshots.push(performance.memory.usedJSHeapSize);
               }

               // Create and destroy objects rapidly
               for (let i = 0; i < iterations; i++) {
                 const objects = [];
                 
                 // Create objects
                 for (let j = 0; j < 10; j++) {
                   if (j % 2 === 0) {
                     objects.push(new wasmModule.TextBlot(`Leak test ${cycle}-${i}-${j}`));
                   } else {
                     objects.push(new wasmModule.ScrollBlot());
                   }
                 }
                 
                 // Use objects
                 objects.forEach(obj => {
                   if (obj.append_text) {
                     obj.append_text("test");
                   }
                 });
                 
                 // Free objects
                 objects.forEach(obj => obj.free());
               }

               updateProgress("memory-progress", ((cycle + 1) / 5) * 100);
               await new Promise(resolve => setTimeout(resolve, 100));
               
               // Force garbage collection if available
               if (window.gc) {
                 window.gc();
               }
             }

             if (performance.memory) {
               memorySnapshots.push(performance.memory.usedJSHeapSize);
               
               const initial = memorySnapshots[0];
               const final = memorySnapshots[memorySnapshots.length - 1];
               const maxGrowth = Math.max(...memorySnapshots) - initial;
               const finalGrowth = final - initial;
               
               const leakDetected = finalGrowth > 5 * 1024 * 1024; // 5MB threshold

               log("memory-results", `‚úÖ Leak detection test completed`, "success");
               log("memory-results", `üìä Memory growth: ${(finalGrowth / 1024 / 1024).toFixed(2)}MB`, "info");
               log("memory-results", `üìà Max growth: ${(maxGrowth / 1024 / 1024).toFixed(2)}MB`, "info");
               log("memory-results", `üîç Leak status: ${leakDetected ? "POTENTIAL LEAK DETECTED" : "NO LEAKS DETECTED"}`, 
                   leakDetected ? "warning" : "success");

               updateSummaryTable("Memory Leak Test", iterations * 5, 0, 0, 
                                 `${(finalGrowth / 1024 / 1024).toFixed(1)}MB growth`, 
                                 leakDetected ? "warning" : "success");
             } else {
               log("memory-results", `‚úÖ Leak detection completed (detailed metrics unavailable)`, "success");
               updateSummaryTable("Memory Leak Test", iterations * 5, 0, 0, "N/A", "success");
             }

             globalStats.totalOperations += iterations * 5;
             updateGlobalStats();
             setStatus("memory-status", "success");
           } catch (e) {
             log("memory-results", `‚ùå Leak detection error: ${e}`, "error");
             setStatus("memory-status", "error");
           }
         });

       document
         .getElementById("memory-gc")
         .addEventListener("click", async () => {
           setStatus("memory-status", "running");
           updateProgress("memory-progress", 0);

           try {
             log("memory-results", "üóëÔ∏è Starting garbage collection stress test...", "info");

             const cycles = 10;
             const objectsPerCycle = 200;

             for (let cycle = 0; cycle < cycles; cycle++) {
               const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
               
               // Create many objects
               const objects = [];
               for (let i = 0; i < objectsPerCycle; i++) {
                 if (i % 3 === 0) {
                   objects.push(new wasmModule.TextBlot(`GC test ${cycle}-${i} with substantial content for memory pressure testing`));
                 } else {
                   const scroll = new wasmModule.ScrollBlot();
                   scroll.append_text(`GC ScrollBlot ${cycle}-${i}`);
                   objects.push(scroll);
                 }
               }

               // Use objects to prevent optimization
               objects.forEach((obj, i) => {
                 if (obj.append_text && i % 2 === 0) {
                   obj.append_text(" modified");
                 }
                 if (obj.get_statistics) {
                   obj.get_statistics();
                 }
               });

               // Free half the objects
               for (let i = 0; i < objects.length; i += 2) {
                 objects[i].free();
               }

               // Force GC if available
               if (window.gc) {
                 window.gc();
               }

               // Free remaining objects
               for (let i = 1; i < objects.length; i += 2) {
                 objects[i].free();
               }

               const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
               const memoryDiff = endMemory - startMemory;

               log("memory-results", `üîÑ Cycle ${cycle + 1}: ${(memoryDiff / 1024).toFixed(1)}KB net change`, "info");
               updateProgress("memory-progress", ((cycle + 1) / cycles) * 100);
               
               await new Promise(resolve => setTimeout(resolve, 200));
             }

             globalStats.totalOperations += cycles * objectsPerCycle;
             updateGlobalStats();

             log("memory-results", `‚úÖ GC stress test completed`, "success");
             log("memory-results", `üìä Processed ${cycles * objectsPerCycle} objects across ${cycles} cycles`, "highlight");
             updateSummaryTable("GC Stress Test", cycles * objectsPerCycle, 0, 0, "GC Tested", "success");
             setStatus("memory-status", "success");
           } catch (e) {
             log("memory-results", `‚ùå GC stress test error: ${e}`, "error");
             setStatus("memory-status", "error");
           }
         });

       document
         .getElementById("memory-extreme")
         .addEventListener("click", async () => {
           setStatus("memory-status", "running");
           updateProgress("memory-progress", 0);

           try {
             log("memory-results", "üí• Starting EXTREME memory test...", "warning");

             const startTime = performance.now();
             const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
             const iterations = 2000;

             // Extreme memory pressure test
             for (let batch = 0; batch < 10; batch++) {
               const objects = [];
               
               // Create large batch of objects
               for (let i = 0; i < iterations / 10; i++) {
                 const textBlot = new wasmModule.TextBlot(
                   `EXTREME TEST ${batch}-${i}: This is substantial content designed to create significant memory pressure with extensive text data for comprehensive memory management testing under extreme conditions.`
                 );
                 
                 const scrollBlot = new wasmModule.ScrollBlot();
                 scrollBlot.append_text(`Extreme ScrollBlot ${batch}-${i} with multiple paragraphs.`);
                 scrollBlot.append_text(`Additional content for memory pressure testing.`);
                 
                 objects.push(textBlot, scrollBlot);
               }

               // Perform operations on all objects
               objects.forEach((obj, i) => {
                 if (obj.append_text && i % 4 === 0) {
                   obj.append_text(" EXTREME_MODIFICATION");
                 }
                 if (obj.get_statistics && i % 3 === 0) {
                   obj.get_statistics();
                 }
               });

               // Free all objects in batch
               objects.forEach(obj => obj.free());

               const currentMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
               const memoryUsed = (currentMemory - startMemory) / 1024 / 1024;

               log("memory-results", `üí• Batch ${batch + 1}/10: ${memoryUsed.toFixed(1)}MB used`, "warning");
               updateProgress("memory-progress", ((batch + 1) / 10) * 100);
               
               await new Promise(resolve => setTimeout(resolve, 100));
             }

             const endTime = performance.now();
             const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
             const totalTime = endTime - startTime;
             const memoryDiff = endMemory - startMemory;

             globalStats.totalOperations += iterations * 2; // TextBlot + ScrollBlot
             globalStats.totalTime += totalTime;
             updateGlobalStats();

             log("memory-results", `üí• EXTREME MEMORY TEST COMPLETED!`, "highlight");
             log("memory-results", `üìä ${(iterations * 2).toLocaleString()} objects in ${totalTime.toFixed(2)}ms`, "success");
             log("memory-results", `üß† Peak memory impact: ${(memoryDiff / 1024 / 1024).toFixed(2)}MB`, "warning");
             log("memory-results", `‚ö° Performance: ${Math.round((iterations * 2 * 1000) / totalTime)} objects/sec`, "highlight");

             updateSummaryTable("Memory Extreme", iterations * 2, totalTime / (iterations * 2), 
                               Math.round((iterations * 2 * 1000) / totalTime), 
                               `${(memoryDiff / 1024 / 1024).toFixed(1)}MB`, "success");
             setStatus("memory-status", "success");
           } catch (e) {
             log("memory-results", `‚ùå EXTREME memory test error: ${e}`, "error");
             setStatus("memory-status", "error");
           }
         });
       // DOM Integration Tests
       document
         .getElementById("dom-basic")
         .addEventListener("click", async () => {
           setStatus("dom-status", "running");
           updateProgress("dom-progress", 0);

           try {
             log("dom-results", "üåê Starting basic DOM operations test...", "info");

             const iterations = 100;
             const startTime = performance.now();

             for (let i = 0; i < iterations; i++) {
               const scroll = new wasmModule.ScrollBlot();
               
               // Create DOM element
               const element = document.createElement("div");
               element.textContent = `DOM test ${i}`;
               document.body.appendChild(element);
               
               // Test DOM integration
               scroll.append_text(element.textContent);
               const content = scroll.text_content();
               
               // Cleanup
               document.body.removeChild(element);
               scroll.free();
               
               updateProgress("dom-progress", (i / iterations) * 100);
               
               if (i % 20 === 0) {
                 await new Promise(resolve => setTimeout(resolve, 1));
               }
             }

             const totalTime = performance.now() - startTime;
             const avgTime = totalTime / iterations;
             const opsPerSec = Math.round((iterations * 1000) / totalTime);

             globalStats.totalOperations += iterations;
             globalStats.totalTime += totalTime;
             updateGlobalStats();

             log("dom-results", `‚úÖ DOM basic test completed: ${avgTime.toFixed(4)}ms avg`, "success");
             updateSummaryTable("DOM Basic", iterations, avgTime, opsPerSec, "Low", "success");
             setStatus("dom-status", "success");
           } catch (e) {
             log("dom-results", `‚ùå DOM basic test error: ${e}`, "error");
             setStatus("dom-status", "error");
           }
         });

       document
         .getElementById("dom-manipulation")
         .addEventListener("click", async () => {
           setStatus("dom-status", "running");
           updateProgress("dom-progress", 0);

           try {
             log("dom-results", "üîß Starting DOM manipulation test...", "info");

             const iterations = 50;
             const startTime = performance.now();

             for (let i = 0; i < iterations; i++) {
               const scroll = new wasmModule.ScrollBlot();
               
               // Create complex DOM structure
               const container = document.createElement("div");
               container.innerHTML = `
                 <p>Paragraph ${i}</p>
                 <span>Span content</span>
                 <strong>Bold text</strong>
               `;
               document.body.appendChild(container);
               
               // Extract and process text
               const textContent = container.textContent;
               scroll.append_text(textContent);
               
               // Manipulate content
               scroll.append_text(" - Modified");
               const stats = scroll.get_statistics();
               
               // Update DOM
               container.setAttribute("data-words", stats.words.toString());
               
               // Cleanup
               document.body.removeChild(container);
               scroll.free();
               
               updateProgress("dom-progress", (i / iterations) * 100);
               await new Promise(resolve => setTimeout(resolve, 10));
             }

             const totalTime = performance.now() - startTime;
             const avgTime = totalTime / iterations;
             const opsPerSec = Math.round((iterations * 1000) / totalTime);

             globalStats.totalOperations += iterations;
             globalStats.totalTime += totalTime;
             updateGlobalStats();

             log("dom-results", `‚úÖ DOM manipulation test completed: ${avgTime.toFixed(2)}ms avg`, "success");
             updateSummaryTable("DOM Manipulation", iterations, avgTime, opsPerSec, "Medium", "success");
             setStatus("dom-status", "success");
           } catch (e) {
             log("dom-results", `‚ùå DOM manipulation test error: ${e}`, "error");
             setStatus("dom-status", "error");
           }
         });

       document
         .getElementById("dom-events")
         .addEventListener("click", async () => {
           setStatus("dom-status", "running");
           updateProgress("dom-progress", 0);

           try {
             log("dom-results", "‚ö° Starting DOM event handling test...", "info");

             const iterations = 30;
             const startTime = performance.now();
             let eventCount = 0;

             for (let i = 0; i < iterations; i++) {
               const scroll = new wasmModule.ScrollBlot();
               const input = document.createElement("textarea");
               input.value = `Event test ${i}`;
               document.body.appendChild(input);

               // Simulate events
               const events = ['input', 'keydown', 'keyup', 'focus', 'blur'];
               
               events.forEach(eventType => {
                 const handler = () => {
                   scroll.append_text(input.value);
                   eventCount++;
                 };
                 
                 input.addEventListener(eventType, handler);
                 input.dispatchEvent(new Event(eventType));
                 input.removeEventListener(eventType, handler);
               });

               document.body.removeChild(input);
               scroll.free();
               
               updateProgress("dom-progress", (i / iterations) * 100);
               await new Promise(resolve => setTimeout(resolve, 20));
             }

             const totalTime = performance.now() - startTime;
             const avgTime = totalTime / iterations;
             const opsPerSec = Math.round((iterations * 1000) / totalTime);

             globalStats.totalOperations += iterations;
             globalStats.totalTime += totalTime;
             updateGlobalStats();

             log("dom-results", `‚úÖ DOM events test completed: ${eventCount} events processed`, "success");
             log("dom-results", `üìä Average: ${avgTime.toFixed(2)}ms per iteration`, "info");
             updateSummaryTable("DOM Events", iterations, avgTime, opsPerSec, "Medium", "success");
             setStatus("dom-status", "success");
           } catch (e) {
             log("dom-results", `‚ùå DOM events test error: ${e}`, "error");
             setStatus("dom-status", "error");
           }
         });

       document
         .getElementById("dom-stress")
         .addEventListener("click", async () => {
           setStatus("dom-status", "running");
           updateProgress("dom-progress", 0);

           try {
             log("dom-results", "üî• Starting DOM stress test...", "warning");

             const iterations = 200;
             const startTime = performance.now();
             const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;

             for (let i = 0; i < iterations; i++) {
               const scroll = new wasmModule.ScrollBlot();
               const elements = [];

               // Create multiple DOM elements
               for (let j = 0; j < 10; j++) {
                 const element = document.createElement("div");
                 element.innerHTML = `<p>Stress test ${i}-${j}</p><span>Content</span>`;
                 document.body.appendChild(element);
                 elements.push(element);
                 
                 scroll.append_text(element.textContent);
               }

               // Process content
               const stats = scroll.get_statistics();
               const content = scroll.text_content();

               // Cleanup
               elements.forEach(el => document.body.removeChild(el));
               scroll.free();
               
               updateProgress("dom-progress", (i / iterations) * 100);
               
               if (i % 20 === 0) {
                 await new Promise(resolve => setTimeout(resolve, 1));
               }
             }

             const totalTime = performance.now() - startTime;
             const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
             const avgTime = totalTime / iterations;
             const opsPerSec = Math.round((iterations * 1000) / totalTime);
             const memoryDiff = endMemory - startMemory;

             globalStats.totalOperations += iterations;
             globalStats.totalTime += totalTime;
             updateGlobalStats();

             log("dom-results", `üî• DOM stress test completed!`, "highlight");
             log("dom-results", `üìä ${iterations} iterations in ${totalTime.toFixed(2)}ms`, "success");
             log("dom-results", `üß† Memory impact: ${(memoryDiff / 1024 / 1024).toFixed(2)}MB`, "info");
             updateSummaryTable("DOM Stress", iterations, avgTime, opsPerSec, `${(memoryDiff / 1024 / 1024).toFixed(1)}MB`, "success");
             setStatus("dom-status", "success");
           } catch (e) {
             log("dom-results", `‚ùå DOM stress test error: ${e}`, "error");
             setStatus("dom-status", "error");
           }
         });

       // Performance Comparison Tests
       document
         .getElementById("comparison-native")
         .addEventListener("click", async () => {
           setStatus("comparison-status", "running");
           updateProgress("comparison-progress", 0);

           try {
             log("comparison-results", "‚öñÔ∏è Starting WASM vs Native JS comparison...", "info");

             const iterations = 1000;
             const testText = "Performance comparison test with substantial content for realistic benchmarking";

             // WASM Test
             updateProgress("comparison-progress", 25);
             const wasmStart = performance.now();
             for (let i = 0; i < iterations; i++) {
               const blot = new wasmModule.TextBlot(testText);
               blot.insert_at(0, `${i} `);
               blot.delete_at(blot.length() - 5, 2);
               const value = blot.value;
               blot.free();
             }
             const wasmTime = performance.now() - wasmStart;

             updateProgress("comparison-progress", 75);
             
             // Native JS Test
             const jsStart = performance.now();
             for (let i = 0; i < iterations; i++) {
               let text = testText;
               text = `${i} ` + text;
               text = text.slice(0, -2);
               const length = text.length;
             }
             const jsTime = performance.now() - jsStart;

             updateProgress("comparison-progress", 100);

             const wasmOpsPerSec = Math.round((iterations * 1000) / wasmTime);
             const jsOpsPerSec = Math.round((iterations * 1000) / jsTime);
             const speedRatio = (jsTime / wasmTime).toFixed(2);

             globalStats.totalOperations += iterations * 2;
             globalStats.totalTime += wasmTime + jsTime;
             updateGlobalStats();

             log("comparison-results", `ü¶Ä WASM: ${wasmTime.toFixed(2)}ms (${wasmOpsPerSec.toLocaleString()} ops/sec)`, "info");
             log("comparison-results", `üü® Native JS: ${jsTime.toFixed(2)}ms (${jsOpsPerSec.toLocaleString()} ops/sec)`, "info");
             log("comparison-results", `üìä WASM is ${speedRatio}x ${wasmTime < jsTime ? 'faster' : 'slower'} than native JS`, "highlight");
             
             updateSummaryTable("WASM vs JS", iterations * 2, (wasmTime + jsTime) / (iterations * 2), 
                               Math.round(((iterations * 2) * 1000) / (wasmTime + jsTime)), 
                               `${speedRatio}x`, wasmTime < jsTime ? "success" : "warning");
             setStatus("comparison-status", "success");
           } catch (e) {
             log("comparison-results", `‚ùå Comparison test error: ${e}`, "error");
             setStatus("comparison-status", "error");
           }
         });

       document
         .getElementById("comparison-baseline")
         .addEventListener("click", async () => {
           setStatus("comparison-status", "running");
           updateProgress("comparison-progress", 0);

           try {
             log("comparison-results", "üìä Running WASM baseline performance test...", "info");

             const tests = [
               { name: "TextBlot Creation", iterations: 1000, operation: () => {
                 const blot = new wasmModule.TextBlot("Baseline test");
                 blot.free();
               }},
               { name: "Text Insertion", iterations: 500, operation: () => {
                 const blot = new wasmModule.TextBlot("Test");
                 blot.insert_at(0, "Inserted ");
                 blot.free();
               }},
               { name: "Text Statistics", iterations: 200, operation: () => {
                 const scroll = new wasmModule.ScrollBlot();
                 scroll.append_text("Statistics test content");
                 const stats = scroll.get_statistics();
                 scroll.free();
               }}
             ];

             const results = [];

             for (let testIndex = 0; testIndex < tests.length; testIndex++) {
               const test = tests[testIndex];
               const startTime = performance.now();

               for (let i = 0; i < test.iterations; i++) {
                 test.operation();
               }

               const endTime = performance.now();
               const totalTime = endTime - startTime;
               const avgTime = totalTime / test.iterations;
               const opsPerSec = Math.round((test.iterations * 1000) / totalTime);

               results.push({ name: test.name, avgTime, opsPerSec, totalTime });
               
               updateProgress("comparison-progress", ((testIndex + 1) / tests.length) * 100);
               
               log("comparison-results", `‚úÖ ${test.name}: ${avgTime.toFixed(4)}ms avg, ${opsPerSec} ops/sec`, "success");
               await new Promise(resolve => setTimeout(resolve, 100));
             }

             const totalOps = tests.reduce((sum, test) => sum + test.iterations, 0);
             const totalTime = results.reduce((sum, result) => sum + result.totalTime, 0);

             globalStats.totalOperations += totalOps;
             globalStats.totalTime += totalTime;
             updateGlobalStats();

             log("comparison-results", `üìä Baseline established with ${totalOps} operations`, "highlight");
             updateSummaryTable("WASM Baseline", totalOps, totalTime / totalOps, 
                               Math.round((totalOps * 1000) / totalTime), "Baseline", "success");
             setStatus("comparison-status", "success");
           } catch (e) {
             log("comparison-results", `‚ùå Baseline test error: ${e}`, "error");
             setStatus("comparison-status", "error");
           }
         });

       document
         .getElementById("comparison-complex")
         .addEventListener("click", async () => {
           setStatus("comparison-status", "running");
           updateProgress("comparison-progress", 0);

           try {
             log("comparison-results", "üßÆ Starting complex operations comparison...", "info");

             const iterations = 100;
             
             // Complex WASM operations
             const wasmStart = performance.now();
             for (let i = 0; i < iterations; i++) {
               const scroll = new wasmModule.ScrollBlot();
               
               // Complex document operations
               for (let j = 0; j < 10; j++) {
                 scroll.append_text(`Complex paragraph ${i}-${j} with substantial content for realistic testing scenarios.`);
               }
               
               const stats = scroll.get_statistics();
               const content = scroll.text_content();
               const matches = scroll.find_text("Complex", false);
               scroll.replace_all("Complex", "Modified", false);
               
               scroll.free();
               updateProgress("comparison-progress", (i / iterations) * 100);
               
               if (i % 10 === 0) {
                 await new Promise(resolve => setTimeout(resolve, 1));
               }
             }
             const wasmTime = performance.now() - wasmStart;

             // Equivalent JS operations
             const jsStart = performance.now();
             for (let i = 0; i < iterations; i++) {
               let document = "";
               
               for (let j = 0; j < 10; j++) {
                 document += `Complex paragraph ${i}-${j} with substantial content for realistic testing scenarios.\n`;
               }
               
               const words = document.split(/\s+/).length;
               const chars = document.length;
               const matches = (document.match(/Complex/g) || []).length;
               document = document.replace(/Complex/g, "Modified");
             }
             const jsTime = performance.now() - jsStart;

             const wasmOpsPerSec = Math.round((iterations * 1000) / wasmTime);
             const jsOpsPerSec = Math.round((iterations * 1000) / jsTime);
             const speedRatio = (jsTime / wasmTime).toFixed(2);

             globalStats.totalOperations += iterations * 2;
             globalStats.totalTime += wasmTime + jsTime;
             updateGlobalStats();

             log("comparison-results", `ü¶Ä WASM Complex: ${wasmTime.toFixed(2)}ms (${wasmOpsPerSec} ops/sec)`, "info");
             log("comparison-results", `üü® JS Complex: ${jsTime.toFixed(2)}ms (${jsOpsPerSec} ops/sec)`, "info");
             log("comparison-results", `üìä Complex operations: WASM is ${speedRatio}x ${wasmTime < jsTime ? 'faster' : 'slower'}`, "highlight");
             
             updateSummaryTable("Complex Ops", iterations * 2, (wasmTime + jsTime) / (iterations * 2), 
                               Math.round(((iterations * 2) * 1000) / (wasmTime + jsTime)), 
                               `${speedRatio}x`, wasmTime < jsTime ? "success" : "warning");
             setStatus("comparison-status", "success");
           } catch (e) {
             log("comparison-results", `‚ùå Complex comparison error: ${e}`, "error");
             setStatus("comparison-status", "error");
           }
         });

       document
         .getElementById("comparison-report")
         .addEventListener("click", () => {
           try {
             log("comparison-results", "üìã Generating performance comparison report...", "info");
             
             const report = {
               timestamp: new Date().toISOString(),
               browser: navigator.userAgent,
               wasmLoadTime: document.getElementById("wasmLoadTime").textContent,
               globalStats: globalStats,
               summary: "Performance comparison completed successfully"
             };

             log("comparison-results", `‚úÖ Report generated with ${globalStats.totalOperations} total operations`, "success");
             log("comparison-results", `üìä Average operation time: ${(globalStats.totalTime / globalStats.totalOperations).toFixed(4)}ms`, "info");
             setStatus("comparison-status", "success");
           } catch (e) {
             log("comparison-results", `‚ùå Report generation error: ${e}`, "error");
             setStatus("comparison-status", "error");
           }
         });

       // Real-world Scenarios Tests
       document
         .getElementById("realworld-typing")
         .addEventListener("click", async () => {
           setStatus("realworld-status", "running");
           updateProgress("realworld-progress", 0);

           try {
             log("realworld-results", "‚å®Ô∏è Starting typing simulation test...", "info");

             const scroll = new wasmModule.ScrollBlot();
             const typingText = "The quick brown fox jumps over the lazy dog. This sentence contains every letter of the alphabet.";
             
             // Simulate realistic typing with delays
             for (let i = 0; i < typingText.length; i++) {
               const char = typingText[i];
               scroll.append_text(char);
               
               // Simulate typing speed variations
               const delay = char === ' ' ? 100 : Math.random() * 50 + 25;
               await new Promise(resolve => setTimeout(resolve, delay));
               
               updateProgress("realworld-progress", (i / typingText.length) * 100);
               
               if (i % 10 === 0) {
                 const stats = scroll.get_statistics();
                 log("realworld-results", `üìù Typed ${i} chars, ${stats.words} words`, "info");
               }
             }

             const finalStats = scroll.get_statistics();
             scroll.free();

             globalStats.totalOperations += typingText.length;
             updateGlobalStats();

             log("realworld-results", `‚úÖ Typing simulation completed!`, "success");
             log("realworld-results", `üìä Final: ${finalStats.words} words, ${finalStats.characters} characters`, "highlight");
             updateSummaryTable("Typing Simulation", typingText.length, 0, 0, "Realistic", "success");
             setStatus("realworld-status", "success");
           } catch (e) {
             log("realworld-results", `‚ùå Typing simulation error: ${e}`, "error");
             setStatus("realworld-status", "error");
           }
         });

       document
         .getElementById("realworld-editing")
         .addEventListener("click", async () => {
           setStatus("realworld-status", "running");
           updateProgress("realworld-progress", 0);

           try {
             log("realworld-results", "üìù Starting document editing simulation...", "info");

             const scroll = new wasmModule.ScrollBlot();
             
             // Create initial document
             const paragraphs = [
               "Introduction: This is a sample document for testing realistic editing scenarios.",
               "Content: We will perform various editing operations like insertion, deletion, and replacement.",
               "Conclusion: These operations simulate real-world document editing workflows."
             ];

             paragraphs.forEach(p => scroll.append_text(p + "\n"));
             updateProgress("realworld-progress", 25);

             // Simulate editing operations
             const operations = [
               () => scroll.find_text("sample", false),
               () => scroll.replace_text("sample", "comprehensive", null),
               () => scroll.append_text("Additional content added during editing."),
               () => scroll.get_statistics(),
               () => scroll.text_content(),
             ];

             for (let i = 0; i < operations.length; i++) {
               const operation = operations[i];
               const startTime = performance.now();
               const result = operation();
               const duration = performance.now() - startTime;
               
               log("realworld-results", `‚úèÔ∏è Operation ${i + 1} completed in ${duration.toFixed(2)}ms`, "info");
               updateProgress("realworld-progress", 25 + ((i + 1) / operations.length) * 75);
               
               await new Promise(resolve => setTimeout(resolve, 200));
             }

             const finalStats = scroll.get_statistics();
             scroll.free();

             globalStats.totalOperations += operations.length;
             updateGlobalStats();

             log("realworld-results", `‚úÖ Document editing simulation completed!`, "success");
             log("realworld-results", `üìä Final document: ${finalStats.words} words, ${finalStats.paragraphs} paragraphs`, "highlight");
             updateSummaryTable("Document Editing", operations.length, 0, 0, "Realistic", "success");
             setStatus("realworld-status", "success");
           } catch (e) {
             log("realworld-results", `‚ùå Document editing error: ${e}`, "error");
             setStatus("realworld-status", "error");
           }
         });

       document
         .getElementById("realworld-collaboration")
         .addEventListener("click", async () => {
           setStatus("realworld-status", "running");
           updateProgress("realworld-progress", 0);

           try {
             log("realworld-results", "üë• Starting multi-user collaboration simulation...", "info");

             const documents = [];
             const users = ["Alice", "Bob", "Charlie"];

             // Create documents for each user
             for (let i = 0; i < users.length; i++) {
               const scroll = new wasmModule.ScrollBlot();
               scroll.append_text(`Document by ${users[i]}: Initial content for collaboration testing.`);
               documents.push({ user: users[i], document: scroll });
               
               updateProgress("realworld-progress", (i / users.length) * 30);
               await new Promise(resolve => setTimeout(resolve, 100));
             }

             // Simulate collaborative editing
             for (let round = 0; round < 5; round++) {
               for (let i = 0; i < documents.length; i++) {
                 const doc = documents[i];
                 
                 // Simulate user actions
                 doc.document.append_text(`\nEdit ${round + 1} by ${doc.user}.`);
                 const stats = doc.document.get_statistics();
                 
                 log("realworld-results", `üë§ ${doc.user} made edit ${round + 1} (${stats.words} words total)`, "info");
                 
                 updateProgress("realworld-progress", 30 + ((round * documents.length + i + 1) / (5 * documents.length)) * 70);
                 await new Promise(resolve => setTimeout(resolve, 150));
               }
             }

             // Merge and analyze
             const mergedContent = documents.map(d => d.document.text_content()).join("\n---\n");
             const finalScroll = new wasmModule.ScrollBlot();
             finalScroll.append_text(mergedContent);
             const finalStats = finalScroll.get_statistics();

             // Cleanup
             documents.forEach(d => d.document.free());
             finalScroll.free();

             globalStats.totalOperations += documents.length * 5;
             updateGlobalStats();

             log("realworld-results", `‚úÖ Multi-user collaboration simulation completed!`, "success");
             log("realworld-results", `üìä Merged document: ${finalStats.words} words from ${users.length} users`, "highlight");
             updateSummaryTable("Collaboration", documents.length * 5, 0, 0, "Multi-user", "success");
             setStatus("realworld-status", "success");
           } catch (e) {
             log("realworld-results", `‚ùå Collaboration simulation error: ${e}`, "error");
             setStatus("realworld-status", "error");
           }
         });

       document
         .getElementById("realworld-suite")
         .addEventListener("click", async () => {
           log("realworld-results", "üéØ Running complete real-world test suite...", "highlight");
           
           await new Promise(resolve => {
             document.getElementById("realworld-typing").click();
             setTimeout(resolve, 2000);
           });
           
           await new Promise(resolve => {
             document.getElementById("realworld-editing").click();
             setTimeout(resolve, 3000);
           });
           
           await new Promise(resolve => {
             document.getElementById("realworld-collaboration").click();
             setTimeout(resolve, 4000);
           });
           
           log("realworld-results", "üéâ Complete real-world test suite finished!", "highlight");
         });

       // Master Controls
       document
         .getElementById("runAllBasic")
         .addEventListener("click", async () => {
           log("textblot-results", "üöÄ Running all basic tests...", "highlight");

           await new Promise((resolve) => {
             document.getElementById("textblot-basic").click();
             setTimeout(resolve, 1000);
           });

           await new Promise((resolve) => {
             document.getElementById("scrollblot-basic").click();
             setTimeout(resolve, 1000);
           });

           await new Promise((resolve) => {
             document.getElementById("memory-basic").click();
             setTimeout(resolve, 1000);
           });

           await new Promise((resolve) => {
             document.getElementById("dom-basic").click();
             setTimeout(resolve, 1000);
           });

           await new Promise((resolve) => {
             document.getElementById("comparison-baseline").click();
             setTimeout(resolve, 1000);
           });

           await new Promise((resolve) => {
             document.getElementById("realworld-typing").click();
             setTimeout(resolve, 2000);
           });

           log("textblot-results", "üéâ All basic tests completed!", "highlight");
         });

       document
         .getElementById("runAllIntensive")
         .addEventListener("click", async () => {
           log("textblot-results", "‚ö° Running all intensive tests...", "highlight");

           await new Promise((resolve) => {
             document.getElementById("textblot-intensive").click();
             setTimeout(resolve, 3000);
           });

           await new Promise((resolve) => {
             document.getElementById("scrollblot-large").click();
             setTimeout(resolve, 2000);
           });

           await new Promise((resolve) => {
             document.getElementById("dom-manipulation").click();
             setTimeout(resolve, 2000);
           });

           await new Promise((resolve) => {
             document.getElementById("comparison-native").click();
             setTimeout(resolve, 2000);
           });

           await new Promise((resolve) => {
             document.getElementById("realworld-editing").click();
             setTimeout(resolve, 3000);
           });

           log("textblot-results", "üéâ All intensive tests completed!", "highlight");
         });

       document
         .getElementById("runAllStress")
         .addEventListener("click", async () => {
           log("textblot-results", "üî• Running all stress tests...", "highlight");

           await new Promise((resolve) => {
             document.getElementById("textblot-stress").click();
             setTimeout(resolve, 5000);
           });

           await new Promise((resolve) => {
             document.getElementById("scrollblot-stress").click();
             setTimeout(resolve, 4000);
           });

           await new Promise((resolve) => {
             document.getElementById("memory-extreme").click();
             setTimeout(resolve, 3000);
           });

           await new Promise((resolve) => {
             document.getElementById("dom-stress").click();
             setTimeout(resolve, 3000);
           });

           await new Promise((resolve) => {
             document.getElementById("comparison-complex").click();
             setTimeout(resolve, 3000);
           });

           await new Promise((resolve) => {
             document.getElementById("realworld-suite").click();
             setTimeout(resolve, 8000);
           });

           log("textblot-results", "üéâ All stress tests completed!", "highlight");
          });
      document
        .getElementById("clearAllResults")
        .addEventListener("click", () => {
          document.querySelectorAll(".results").forEach((container) => {
            container.innerHTML = "Results cleared...";
          });

          document.querySelectorAll(".progress-fill").forEach((progress) => {
            progress.style.width = "0%";
          });

          document
            .querySelectorAll(".status-indicator")
            .forEach((indicator) => {
              indicator.className = "status-indicator status-ready";
            });

          document.getElementById("summaryTableBody").innerHTML = `
                <tr>
                    <td colspan="6" style="text-align: center; color: #7f8c8d; font-style: italic;">
                        Run benchmarks to see results...
                    </td>
                </tr>
            `;

          // Reset global stats
          globalStats = {
            totalOperations: 0,
            totalTime: 0,
            memoryBaseline: performance.memory
              ? performance.memory.usedJSHeapSize
              : 0,
            testResults: new Map(),
          };

          updateGlobalStats();
        });

      document.getElementById("exportResults").addEventListener("click", () => {
        const results = {
          timestamp: new Date().toISOString(),
          wasmLoadTime: document.getElementById("wasmLoadTime").textContent,
          globalStats: globalStats,
          browserInfo: {
            userAgent: navigator.userAgent,
            language: navigator.language,
            hardwareConcurrency: navigator.hardwareConcurrency,
            memory: performance.memory
              ? {
                  used: performance.memory.usedJSHeapSize,
                  total: performance.memory.totalJSHeapSize,
                  limit: performance.memory.jsHeapSizeLimit,
                }
              : null,
          },
          summaryTable: Array.from(
            document.getElementById("summaryTableBody").children,
          )
            .map((row) => ({
              category: row.children[0]?.textContent,
              operations: row.children[1]?.textContent,
              avgTime: row.children[2]?.textContent,
              opsPerSec: row.children[3]?.textContent,
              memoryImpact: row.children[4]?.textContent,
              status: row.children[5]?.textContent?.trim(),
            }))
            .filter((row) => row.category && row.category !== ""),
        };

        const blob = new Blob([JSON.stringify(results, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = `parchment-wasm-benchmark-${Date.now()}.json`;
        a.click();

        URL.revokeObjectURL(url);

        log(
          "textblot-results",
          "üìä Benchmark results exported successfully",
          "success",
        );
      });

      // Initialize
      document
        .querySelectorAll("button")
        .forEach((btn) => (btn.disabled = true));
      initializeWasm();

      // Update global stats every 2 seconds
      setInterval(updateGlobalStats, 2000);
    </script>
  </body>
</html>
