<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QuillAi Parchment WASM - Basic Usage Example</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1000px;
        margin: 0 auto;
        padding: 20px;
      }
      .demo-section {
        margin: 20px 0;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
      }
      .editor-container {
        border: 2px solid #ccc;
        padding: 10px;
        min-height: 200px;
        background: #fafafa;
        margin: 10px 0;
      }
      .parchment-scroll {
        background: white;
        padding: 10px;
        min-height: 150px;
        border: 1px solid #eee;
      }
      button {
        background: #007bff;
        color: white;
        border: none;
        padding: 8px 15px;
        margin: 5px;
        border-radius: 3px;
        cursor: pointer;
      }
      button:hover {
        background: #0056b3;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .output {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 3px;
        padding: 10px;
        margin: 10px 0;
        font-family: monospace;
        white-space: pre-wrap;
      }
      .success {
        color: #28a745;
      }
      .error {
        color: #dc3545;
      }
    </style>
  </head>
  <body>
    <h1>ü¶Ä QuillAi Parchment WASM Basic Usage Examples</h1>
    <p>
      This demonstrates practical usage of the Rust/WebAssembly Parchment
      implementation.
    </p>

    <!-- Section 1: TextBlot Fundamentals -->
    <div class="demo-section">
      <h2>1. TextBlot Fundamentals</h2>
      <p>TextBlot is the basic building block for all text content.</p>

      <button id="createText">Create TextBlot</button>
      <button id="modifyText">Modify Text</button>
      <button id="splitText">Split Text</button>
      <button id="insertText">Insert Text</button>
      <button id="deleteText">Delete Text</button>

      <div class="output" id="textOutput">
        Click buttons above to test TextBlot operations...
      </div>
    </div>

    <!-- Section 2: ScrollBlot Document Container -->
    <div class="demo-section">
      <h2>2. ScrollBlot Document Container</h2>
      <p>ScrollBlot acts as the root container for the entire document.</p>

      <button id="createScroll">Create ScrollBlot</button>
      <button id="addParagraphs">Add Paragraphs</button>
      <button id="clearDocument">Clear Document</button>
      <button id="inspectDocument">Inspect Document</button>

      <div class="editor-container" id="editorContainer">
        <div id="documentView">Document will appear here...</div>
      </div>

      <div class="output" id="scrollOutput">
        Click buttons above to test ScrollBlot operations...
      </div>
    </div>

    <!-- Section 3: DOM Integration -->
    <div class="demo-section">
      <h2>3. DOM Integration & Manipulation</h2>
      <p>See how QuillAi Parchment WASM integrates with the browser DOM.</p>

      <button id="createDomElements">Create DOM Elements</button>
      <button id="attachToPage">Attach to Page</button>
      <button id="manipulateDom">Manipulate DOM</button>
      <button id="extractContent">Extract Content</button>

      <div id="domPlayground" class="editor-container">
        DOM manipulation playground...
      </div>

      <div class="output" id="domOutput">
        Click buttons above to test DOM integration...
      </div>
    </div>

    <!-- Section 4: Performance & Memory -->
    <div class="demo-section">
      <h2>4. Performance & Memory Management</h2>
      <p>Test performance and proper memory cleanup.</p>

      <button id="performanceTest">Performance Test</button>
      <button id="memoryTest">Memory Test</button>
      <button id="stressTest">Stress Test</button>
      <button id="cleanupTest">Cleanup Test</button>

      <div class="output" id="performanceOutput">
        Click buttons above to test performance...
      </div>
    </div>

    <script type="module">
      let wasmModule;
      let currentScrollBlot = null;

      async function initWasm() {
        try {
          wasmModule = await import("../pkg/quillai_parchment.js");
          await wasmModule.default(); // Initialize WASM
          wasmModule.init_panic_hook();

          console.log("‚úÖ WASM initialized successfully");
          enableAllButtons();
          setupEventListeners();
        } catch (error) {
          console.error("‚ùå Failed to initialize WASM:", error);
          document.body.innerHTML = `<h1>Error loading WASM: ${error}</h1>`;
        }
      }

      function enableAllButtons() {
        document
          .querySelectorAll("button")
          .forEach((btn) => (btn.disabled = false));
      }

      function log(outputId, message, type = "info") {
        const output = document.getElementById(outputId);
        const timestamp = new Date().toLocaleTimeString();
        const className =
          type === "error" ? "error" : type === "success" ? "success" : "";
        output.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
        output.scrollTop = output.scrollHeight;
      }

      function setupEventListeners() {
        // TextBlot Examples
        document.getElementById("createText").addEventListener("click", () => {
          try {
            const textBlot = new wasmModule.TextBlot(
              "Hello, QuillAi Parchment WASM! ü¶Ä",
            );
            log(
              "textOutput",
              `‚úÖ Created TextBlot: "${textBlot.value}" (${textBlot.length()} chars)`,
              "success",
            );

            // Store reference for other operations
            window.currentTextBlot = textBlot;
          } catch (e) {
            log("textOutput", `‚ùå Error creating TextBlot: ${e}`, "error");
          }
        });

        document.getElementById("modifyText").addEventListener("click", () => {
          try {
            if (!window.currentTextBlot) {
              log("textOutput", "‚ö†Ô∏è  Please create a TextBlot first");
              return;
            }

            const newValue = "Modified with WASM power! üöÄ";
            window.currentTextBlot.value = newValue;
            log(
              "textOutput",
              `‚úÖ Modified text to: "${window.currentTextBlot.value}"`,
              "success",
            );
          } catch (e) {
            log("textOutput", `‚ùå Error modifying text: ${e}`, "error");
          }
        });

        document.getElementById("splitText").addEventListener("click", () => {
          try {
            if (!window.currentTextBlot) {
              log("textOutput", "‚ö†Ô∏è  Please create a TextBlot first");
              return;
            }

            const splitIndex = Math.floor(window.currentTextBlot.length() / 2);
            const secondPart = window.currentTextBlot.split(splitIndex);

            log("textOutput", `‚úÖ Split at index ${splitIndex}:`, "success");
            log(
              "textOutput",
              `   First part: "${window.currentTextBlot.value}"`,
            );
            log("textOutput", `   Second part: "${secondPart.value}"`);

            secondPart.free(); // Clean up
          } catch (e) {
            log("textOutput", `‚ùå Error splitting text: ${e}`, "error");
          }
        });

        document.getElementById("insertText").addEventListener("click", () => {
          try {
            if (!window.currentTextBlot) {
              log("textOutput", "‚ö†Ô∏è  Please create a TextBlot first");
              return;
            }

            const insertIndex = 5;
            const insertText = " [INSERTED] ";
            window.currentTextBlot.insert_at(insertIndex, insertText);

            log(
              "textOutput",
              `‚úÖ Inserted "${insertText}" at index ${insertIndex}`,
              "success",
            );
            log("textOutput", `   Result: "${window.currentTextBlot.value}"`);
          } catch (e) {
            log("textOutput", `‚ùå Error inserting text: ${e}`, "error");
          }
        });

        document.getElementById("deleteText").addEventListener("click", () => {
          try {
            if (!window.currentTextBlot) {
              log("textOutput", "‚ö†Ô∏è  Please create a TextBlot first");
              return;
            }

            const deleteIndex = 5;
            const deleteLength = 12; // Length of " [INSERTED] "
            window.currentTextBlot.delete_at(deleteIndex, deleteLength);

            log(
              "textOutput",
              `‚úÖ Deleted ${deleteLength} chars at index ${deleteIndex}`,
              "success",
            );
            log("textOutput", `   Result: "${window.currentTextBlot.value}"`);
          } catch (e) {
            log("textOutput", `‚ùå Error deleting text: ${e}`, "error");
          }
        });

        // ScrollBlot Examples
        document
          .getElementById("createScroll")
          .addEventListener("click", () => {
            try {
              if (currentScrollBlot) {
                currentScrollBlot.free();
              }

              currentScrollBlot = new wasmModule.ScrollBlot();
              log(
                "scrollOutput",
                `‚úÖ Created ScrollBlot (empty: ${currentScrollBlot.is_empty()})`,
                "success",
              );

              // Clear the document view
              document.getElementById("documentView").innerHTML = "";
            } catch (e) {
              log(
                "scrollOutput",
                `‚ùå Error creating ScrollBlot: ${e}`,
                "error",
              );
            }
          });

        document
          .getElementById("addParagraphs")
          .addEventListener("click", () => {
            try {
              if (!currentScrollBlot) {
                log("scrollOutput", "‚ö†Ô∏è  Please create a ScrollBlot first");
                return;
              }

              const paragraphs = [
                "This is the first paragraph written in Rust! ü¶Ä",
                "This is the second paragraph, compiled to WebAssembly! ‚ö°",
                "QuillAi Parchment WASM provides native performance for rich text editing! üöÄ",
              ];

              paragraphs.forEach((text, i) => {
                currentScrollBlot.append_text(text);
                log(
                  "scrollOutput",
                  `‚úÖ Added paragraph ${i + 1}: "${text.substring(0, 30)}..."`,
                  "success",
                );
              });

              log(
                "scrollOutput",
                `üìä Document stats: ${currentScrollBlot.children_count()} children, empty: ${currentScrollBlot.is_empty()}`,
              );

              // Update the visual representation
              updateDocumentView();
            } catch (e) {
              log("scrollOutput", `‚ùå Error adding paragraphs: ${e}`, "error");
            }
          });

        document
          .getElementById("clearDocument")
          .addEventListener("click", () => {
            try {
              if (!currentScrollBlot) {
                log("scrollOutput", "‚ö†Ô∏è  Please create a ScrollBlot first");
                return;
              }

              currentScrollBlot.clear();
              log(
                "scrollOutput",
                `‚úÖ Document cleared (children: ${currentScrollBlot.children_count()})`,
                "success",
              );

              document.getElementById("documentView").innerHTML =
                "Document cleared...";
            } catch (e) {
              log("scrollOutput", `‚ùå Error clearing document: ${e}`, "error");
            }
          });

        document
          .getElementById("inspectDocument")
          .addEventListener("click", () => {
            try {
              if (!currentScrollBlot) {
                log("scrollOutput", "‚ö†Ô∏è  Please create a ScrollBlot first");
                return;
              }

              const textContent = currentScrollBlot.text_content();
              const domElement = currentScrollBlot.dom_element();

              log("scrollOutput", `üìä Document Inspection:`, "success");
              log(
                "scrollOutput",
                `   Children: ${currentScrollBlot.children_count()}`,
              );
              log("scrollOutput", `   Empty: ${currentScrollBlot.is_empty()}`);
              log("scrollOutput", `   Length: ${currentScrollBlot.length()}`);
              log("scrollOutput", `   DOM Tag: ${domElement.tagName}`);
              log("scrollOutput", `   DOM Class: ${domElement.className}`);
              log(
                "scrollOutput",
                `   Text Content: "${textContent.substring(0, 50)}${textContent.length > 50 ? "..." : ""}"`,
              );
            } catch (e) {
              log(
                "scrollOutput",
                `‚ùå Error inspecting document: ${e}`,
                "error",
              );
            }
          });

        // DOM Integration Examples
        document
          .getElementById("createDomElements")
          .addEventListener("click", () => {
            try {
              const textBlot = new wasmModule.TextBlot(
                "This text was created in Rust! ü¶Ä",
              );
              const scrollBlot = new wasmModule.ScrollBlot();

              const textNode = textBlot.dom_node();
              const scrollElement = scrollBlot.dom_element();

              log("domOutput", `‚úÖ Created DOM elements:`, "success");
              log(
                "domOutput",
                `   TextNode: ${textNode.constructor.name} with content: "${textNode.textContent}"`,
              );
              log(
                "domOutput",
                `   ScrollElement: ${scrollElement.constructor.name} with class: "${scrollElement.className}"`,
              );

              // Store for other operations
              window.domTextBlot = textBlot;
              window.domScrollBlot = scrollBlot;
            } catch (e) {
              log("domOutput", `‚ùå Error creating DOM elements: ${e}`, "error");
            }
          });

        document
          .getElementById("attachToPage")
          .addEventListener("click", () => {
            try {
              if (!window.domScrollBlot) {
                log("domOutput", "‚ö†Ô∏è  Please create DOM elements first");
                return;
              }

              const playground = document.getElementById("domPlayground");
              playground.innerHTML = ""; // Clear previous content

              const scrollElement = window.domScrollBlot.dom_element();
              playground.appendChild(scrollElement);

              log(
                "domOutput",
                `‚úÖ Attached ScrollBlot to DOM playground`,
                "success",
              );
              log(
                "domOutput",
                `   Element now visible in the playground above`,
              );
            } catch (e) {
              log("domOutput", `‚ùå Error attaching to page: ${e}`, "error");
            }
          });

        document
          .getElementById("manipulateDom")
          .addEventListener("click", () => {
            try {
              if (!window.domScrollBlot) {
                log(
                  "domOutput",
                  "‚ö†Ô∏è  Please create and attach DOM elements first",
                );
                return;
              }

              window.domScrollBlot.clear();
              window.domScrollBlot.append_text("üöÄ Dynamic content from WASM!");
              window.domScrollBlot.append_text(
                "ü¶Ä Rust performance in the browser!",
              );
              window.domScrollBlot.append_text(
                "‚ö° WebAssembly compilation magic!",
              );

              log(
                "domOutput",
                `‚úÖ Manipulated DOM through WASM interface`,
                "success",
              );
              log(
                "domOutput",
                `   Added 3 new PARAGRAPHS (<p> elements) to the playground`,
              );
            } catch (e) {
              log("domOutput", `‚ùå Error manipulating DOM: ${e}`, "error");
            }
          });

        document
          .getElementById("extractContent")
          .addEventListener("click", () => {
            try {
              if (!window.domScrollBlot) {
                log("domOutput", "‚ö†Ô∏è  Please create DOM elements first");
                return;
              }

              const textContent = window.domScrollBlot.text_content();
              const domElement = window.domScrollBlot.dom_element();
              const innerHTML = domElement.innerHTML;

              log("domOutput", `üì§ Extracted content:`, "success");
              log("domOutput", `   Text content: "${textContent}"`);
              log("domOutput", `   HTML content: "${innerHTML}"`);
              log(
                "domOutput",
                `   Child nodes: ${domElement.childNodes.length}`,
              );
            } catch (e) {
              log("domOutput", `‚ùå Error extracting content: ${e}`, "error");
            }
          });

        // Performance & Memory Examples
        document
          .getElementById("performanceTest")
          .addEventListener("click", () => {
            try {
              const iterations = 1000;
              const startTime = performance.now();

              // Create and manipulate many TextBlots
              const textBlots = [];
              for (let i = 0; i < iterations; i++) {
                const blot = new wasmModule.TextBlot(`Performance test ${i}`);
                blot.insert_at(0, "üöÄ ");
                textBlots.push(blot);
              }

              const endTime = performance.now();
              const duration = endTime - startTime;

              log(
                "performanceOutput",
                `üèÉ‚Äç‚ôÇÔ∏è Performance Test Results:`,
                "success",
              );
              log(
                "performanceOutput",
                `   Created ${iterations} TextBlots in ${duration.toFixed(2)}ms`,
              );
              log(
                "performanceOutput",
                `   Average: ${(duration / iterations).toFixed(4)}ms per TextBlot`,
              );
              log(
                "performanceOutput",
                `   Operations per second: ${(iterations / (duration / 1000)).toFixed(0)}`,
              );

              // Clean up
              textBlots.forEach((blot) => blot.free());
              log(
                "performanceOutput",
                `   ‚úÖ Cleaned up all ${iterations} TextBlots`,
              );
            } catch (e) {
              log(
                "performanceOutput",
                `‚ùå Error in performance test: ${e}`,
                "error",
              );
            }
          });

        document.getElementById("memoryTest").addEventListener("click", () => {
          try {
            const initialMemory = performance.memory
              ? performance.memory.usedJSHeapSize
              : "N/A";

            // Create many objects
            const objects = [];
            for (let i = 0; i < 500; i++) {
              objects.push(new wasmModule.TextBlot(`Memory test ${i}`));
              objects.push(new wasmModule.ScrollBlot());
            }

            const afterCreation = performance.memory
              ? performance.memory.usedJSHeapSize
              : "N/A";

            // Clean up all objects
            objects.forEach((obj) => obj.free());

            // Force garbage collection if available
            if (window.gc) window.gc();

            const afterCleanup = performance.memory
              ? performance.memory.usedJSHeapSize
              : "N/A";

            log("performanceOutput", `üß† Memory Test Results:`, "success");
            log(
              "performanceOutput",
              `   Initial memory: ${formatBytes(initialMemory)}`,
            );
            log(
              "performanceOutput",
              `   After creating 1000 objects: ${formatBytes(afterCreation)}`,
            );
            log(
              "performanceOutput",
              `   After cleanup: ${formatBytes(afterCleanup)}`,
            );
            if (initialMemory !== "N/A" && afterCleanup !== "N/A") {
              const leaked = afterCleanup - initialMemory;
              log(
                "performanceOutput",
                `   Memory difference: ${formatBytes(leaked)} ${leaked > 0 ? "(potential leak)" : "(cleaned up)"}`,
              );
            }
          } catch (e) {
            log("performanceOutput", `‚ùå Error in memory test: ${e}`, "error");
          }
        });

        document.getElementById("stressTest").addEventListener("click", () => {
          try {
            log("performanceOutput", `üî• Starting stress test...`, "success");

            const startTime = performance.now();
            const scrollBlot = new wasmModule.ScrollBlot();

            // Add many paragraphs
            for (let i = 0; i < 100; i++) {
              scrollBlot.append_text(
                `Stress test paragraph ${i} with some longer content to test performance under load. This paragraph contains Unicode characters: ü¶ÄüöÄ‚ö°üî•üíØ`,
              );
            }

            // Test many text operations
            const textBlot = new wasmModule.TextBlot(
              "Initial stress test content",
            );
            for (let i = 0; i < 1000; i++) {
              textBlot.insert_at(0, `${i} `);
              if (i % 100 === 0) {
                const split = textBlot.split(textBlot.length() / 2);
                split.free();
              }
            }

            const endTime = performance.now();
            const duration = endTime - startTime;

            log(
              "performanceOutput",
              `‚úÖ Stress test completed in ${duration.toFixed(2)}ms`,
              "success",
            );
            log(
              "performanceOutput",
              `   ScrollBlot children: ${scrollBlot.children_count()}`,
            );
            log(
              "performanceOutput",
              `   TextBlot length: ${textBlot.length()}`,
            );
            log(
              "performanceOutput",
              `   Performance: ${(2100 / (duration / 1000)).toFixed(0)} operations/sec`,
            );

            // Cleanup
            scrollBlot.free();
            textBlot.free();
          } catch (e) {
            log("performanceOutput", `‚ùå Error in stress test: ${e}`, "error");
          }
        });

        document.getElementById("cleanupTest").addEventListener("click", () => {
          try {
            log(
              "performanceOutput",
              `üßπ Testing cleanup and memory management...`,
              "success",
            );

            // Clean up any existing objects
            if (window.currentTextBlot) {
              window.currentTextBlot.free();
              window.currentTextBlot = null;
              log("performanceOutput", `   ‚úÖ Cleaned up currentTextBlot`);
            }

            if (currentScrollBlot) {
              currentScrollBlot.free();
              currentScrollBlot = null;
              log("performanceOutput", `   ‚úÖ Cleaned up currentScrollBlot`);
            }

            if (window.domTextBlot) {
              window.domTextBlot.free();
              window.domTextBlot = null;
              log("performanceOutput", `   ‚úÖ Cleaned up domTextBlot`);
            }

            if (window.domScrollBlot) {
              window.domScrollBlot.free();
              window.domScrollBlot = null;
              log("performanceOutput", `   ‚úÖ Cleaned up domScrollBlot`);
            }

            // Clear DOM playground
            document.getElementById("domPlayground").innerHTML =
              "DOM manipulation playground...";
            document.getElementById("documentView").innerHTML =
              "Document will appear here...";

            log("performanceOutput", `   ‚úÖ Cleared all DOM elements`);
            log(
              "performanceOutput",
              `üéâ Cleanup completed successfully!`,
              "success",
            );
          } catch (e) {
            log("performanceOutput", `‚ùå Error during cleanup: ${e}`, "error");
          }
        });
      }

      function updateDocumentView() {
        if (!currentScrollBlot) return;

        try {
          const domElement = currentScrollBlot.dom_element();
          const documentView = document.getElementById("documentView");

          // Show the actual DOM structure with proper paragraphs
          const paragraphs = domElement.querySelectorAll("p");

          if (paragraphs.length > 0) {
            documentView.innerHTML = Array.from(paragraphs)
              .map(
                (p, i) =>
                  `<div style="margin: 5px 0; padding: 5px; background: white; border-left: 3px solid #007bff;">
                            <strong>Paragraph ${i + 1}:</strong> &lt;p&gt;${p.textContent}&lt;/p&gt;
                        </div>`,
              )
              .join("");
          } else {
            documentView.innerHTML =
              '<div style="color: #999; font-style: italic;">No paragraphs created yet...</div>';
          }
        } catch (e) {
          console.error("Error updating document view:", e);
        }
      }

      function formatBytes(bytes) {
        if (bytes === "N/A" || bytes === undefined) return "N/A";
        if (bytes === 0) return "0 Bytes";
        const k = 1024;
        const sizes = ["Bytes", "KB", "MB", "GB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
      }

      // Initialize everything
      document
        .querySelectorAll("button")
        .forEach((btn) => (btn.disabled = true));
      initWasm();
    </script>
  </body>
</html>
