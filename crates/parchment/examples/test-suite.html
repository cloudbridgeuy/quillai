<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Parchment WASM Test Suite</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 20px;
        background-color: #f5f5f5;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      h1,
      h2 {
        color: #333;
      }
      .test-section {
        margin: 20px 0;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        background: #f9f9f9;
      }
      .test-result {
        margin: 10px 0;
        padding: 10px;
        border-radius: 4px;
      }
      .test-pass {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
      }
      .test-fail {
        background: #f8d7da;
        border: 1px solid #f5c6cb;
        color: #721c24;
      }
      .test-pending {
        background: #fff3cd;
        border: 1px solid #ffeeba;
        color: #856404;
      }
      .editor-demo {
        border: 1px solid #ccc;
        min-height: 200px;
        padding: 10px;
        margin: 10px 0;
        background: white;
        font-family: "Courier New", monospace;
      }
      button {
        background: #007bff;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        margin: 5px;
      }
      button:hover {
        background: #0056b3;
      }
      .stats {
        display: flex;
        gap: 20px;
        margin: 20px 0;
      }
      .stat {
        padding: 10px;
        border-radius: 4px;
        text-align: center;
        min-width: 100px;
      }
      .stat-total {
        background: #e9ecef;
      }
      .stat-pass {
        background: #d4edda;
      }
      .stat-fail {
        background: #f8d7da;
      }
      .stat-pending {
        background: #fff3cd;
      }
      pre {
        background: #f8f9fa;
        padding: 10px;
        border-radius: 4px;
        overflow-x: auto;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>🚀 Parchment WASM Test Suite</h1>
      <p>
        Comprehensive testing for the Rust/WebAssembly implementation of
        Parchment document model.
      </p>

      <div class="stats" id="test-stats">
        <div class="stat stat-total">
          <strong>Total Tests</strong><br />
          <span id="total-tests">0</span>
        </div>
        <div class="stat stat-pass">
          <strong>Passed</strong><br />
          <span id="passed-tests">0</span>
        </div>
        <div class="stat stat-fail">
          <strong>Failed</strong><br />
          <span id="failed-tests">0</span>
        </div>
        <div class="stat stat-pending">
          <strong>Pending</strong><br />
          <span id="pending-tests">0</span>
        </div>
      </div>

      <button onclick="runAllTests()">🧪 Run All Tests</button>
      <button onclick="clearResults()">🧹 Clear Results</button>
      <button onclick="runPerformanceTests()">⚡ Performance Tests</button>

      <div class="test-section">
        <h2>📦 Phase 1: Basic WASM Functionality</h2>
        <div id="basic-tests"></div>
      </div>

      <div class="test-section">
        <h2>✨ Phase 1.5: Rich Text Formatting</h2>
        <div id="formatting-tests"></div>
      </div>

      <div class="test-section">
        <h2>🏗️ Phase 2: Blot Creation and Management</h2>
        <div id="blot-tests"></div>
      </div>

      <div class="test-section">
        <h2>📝 Phase 3: Text Operations</h2>
        <div id="text-tests"></div>
      </div>

      <div class="test-section">
        <h2>🔧 Phase 4: Advanced Operations</h2>
        <div id="advanced-tests"></div>
      </div>

      <div class="test-section">
        <h2>🔬 Phase 5: Mutation Observer System</h2>
        <div id="mutation-observer-tests"></div>
      </div>

      <div class="test-section">
        <h2>🎯 Multi-Instance Live Editor Demo</h2>
        <p>
          Multiple independent Parchment editor instances to test isolation and
          non-interference:
        </p>

        <!-- Editor Instance 1 -->
        <div
          style="
            margin: 20px 0;
            padding: 15px;
            border: 2px solid #007bff;
            border-radius: 8px;
          "
        >
          <h3 style="margin-top: 0; color: #007bff">
            📝 Editor Instance 1 (Primary)
          </h3>
          <div
            class="editor-demo"
            id="live-editor-1"
            contenteditable="true"
            style="min-height: 120px"
          >
            Type here to test the first editor instance...
          </div>
          <div style="margin: 10px 0; display: flex; flex-wrap: wrap; gap: 5px">
            <button onclick="initParchmentEditor(1)">🚀 Init Editor 1</button>
            <button onclick="insertText(1)">📝 Insert Text</button>
            <button onclick="insertInlineAtCursor(1)">✨ Insert Inline</button>
            <button onclick="insertEmbed(1)">🖼️ Insert Embed</button>
            <button onclick="insertBlock(1)">📄 Insert Block</button>
            <button onclick="deleteLast(1)">🗑️ Delete Last</button>
            <button onclick="showParchmentState(1)">🔍 Show State 1</button>
          </div>
          <div
            id="editor-state-1"
            style="
              margin: 10px 0;
              padding: 10px;
              background: #f0f8ff;
              border-radius: 4px;
              font-family: monospace;
              font-size: 11px;
              display: none;
            "
          >
            <strong>Editor 1 State:</strong>
            <pre id="state-display-1"></pre>
          </div>
        </div>

        <!-- Editor Instance 2 -->
        <div
          style="
            margin: 20px 0;
            padding: 15px;
            border: 2px solid #28a745;
            border-radius: 8px;
          "
        >
          <h3 style="margin-top: 0; color: #28a745">
            📝 Editor Instance 2 (Secondary)
          </h3>
          <div
            class="editor-demo"
            id="live-editor-2"
            contenteditable="true"
            style="min-height: 120px"
          >
            Type here to test the second editor instance...
          </div>
          <div style="margin: 10px 0; display: flex; flex-wrap: wrap; gap: 5px">
            <button onclick="initParchmentEditor(2)">🚀 Init Editor 2</button>
            <button onclick="insertText(2)">📝 Insert Text</button>
            <button onclick="insertInlineAtCursor(2)">✨ Insert Inline</button>
            <button onclick="insertEmbed(2)">🖼️ Insert Embed</button>
            <button onclick="insertBlock(2)">📄 Insert Block</button>
            <button onclick="deleteLast(2)">🗑️ Delete Last</button>
            <button onclick="showParchmentState(2)">🔍 Show State 2</button>
          </div>
          <div
            id="editor-state-2"
            style="
              margin: 10px 0;
              padding: 10px;
              background: #f0fff0;
              border-radius: 4px;
              font-family: monospace;
              font-size: 11px;
              display: none;
            "
          >
            <strong>Editor 2 State:</strong>
            <pre id="state-display-2"></pre>
          </div>
        </div>

        <!-- Editor Instance 3 -->
        <div
          style="
            margin: 20px 0;
            padding: 15px;
            border: 2px solid #dc3545;
            border-radius: 8px;
          "
        >
          <h3 style="margin-top: 0; color: #dc3545">
            📝 Editor Instance 3 (Tertiary)
          </h3>
          <div
            class="editor-demo"
            id="live-editor-3"
            contenteditable="true"
            style="min-height: 120px"
          >
            Type here to test the third editor instance...
          </div>
          <div style="margin: 10px 0; display: flex; flex-wrap: wrap; gap: 5px">
            <button onclick="initParchmentEditor(3)">🚀 Init Editor 3</button>
            <button onclick="insertText(3)">📝 Insert Text</button>
            <button onclick="insertInlineAtCursor(3)">✨ Insert Inline</button>
            <button onclick="insertEmbed(3)">🖼️ Insert Embed</button>
            <button onclick="insertBlock(3)">📄 Insert Block</button>
            <button onclick="deleteLast(3)">🗑️ Delete Last</button>
            <button onclick="showParchmentState(3)">🔍 Show State 3</button>
          </div>
          <div
            id="editor-state-3"
            style="
              margin: 10px 0;
              padding: 10px;
              background: #fff5f5;
              border-radius: 4px;
              font-family: monospace;
              font-size: 11px;
              display: none;
            "
          >
            <strong>Editor 3 State:</strong>
            <pre id="state-display-3"></pre>
          </div>
        </div>

        <!-- Global Controls -->
        <div
          style="
            margin: 20px 0;
            padding: 15px;
            border: 2px solid #6c757d;
            border-radius: 8px;
            background: #f8f9fa;
          "
        >
          <h3 style="margin-top: 0; color: #6c757d">🌐 Global Controls</h3>
          <div style="display: flex; flex-wrap: wrap; gap: 5px">
            <button onclick="initAllEditors()">
              🚀 Initialize All Editors
            </button>
            <button onclick="showAllStates()">🔍 Show All States</button>
            <button onclick="hideAllStates()">👁️ Hide All States</button>
            <button onclick="clearAllEditors()">🧹 Clear All Editors</button>
            <button onclick="performCrossEditorTest()">
              🔄 Cross-Editor Test
            </button>
          </div>
          <div
            id="global-status"
            style="
              margin: 10px 0;
              padding: 10px;
              background: white;
              border-radius: 4px;
              font-family: monospace;
              font-size: 12px;
            "
          >
            <strong>Global Status:</strong> Ready to initialize editors
          </div>
        </div>
      </div>

      <div class="test-section">
        <h2>📊 Performance Metrics</h2>
        <div id="performance-results"></div>
      </div>

      <div class="test-section">
        <h2>🐛 Debug Information</h2>
        <div id="debug-info"></div>
      </div>
    </div>

    <script type="module">
      import init, {
        version,
        create_registry,
        init_panic_hook,
        test_scope_operations,
        test_text_blot,
        test_scroll_blot,
        test_block_blot,
        test_inline_blot,
        test_embed_blot,
        test_registry_blot_creation,
        test_registry_element_detection,
        test_scope_completeness,
        test_mutation_observer_creation,
        test_mutation_observer_dom_changes,
        test_mutation_observer_attributes,
        test_mutation_observer_text_changes,
        test_mutation_observer_node_changes,
        test_mutation_observer_optimization,
        test_registry_instance_management,
        test_bold_formatting,
        test_italic_formatting,
        test_underline_formatting,
        test_code_formatting,
        test_strike_formatting,
        test_all_formatting_types,
      } from "../pkg/quillai_parchment.js";

      let parchment = null;
      let testStats = {
        total: 0,
        passed: 0,
        failed: 0,
        pending: 0,
      };

      // Initialize the WASM module
      async function initializeParchment() {
        try {
          await init();
          init_panic_hook();
          parchment = {
            version,
            create_registry,
            test_scope_operations,
            test_text_blot,
            test_scroll_blot,
            test_block_blot,
            test_inline_blot,
            test_embed_blot,
            test_registry_blot_creation,
            test_registry_element_detection,
            test_scope_completeness,
            test_registry_instance_management,
            test_bold_formatting,
            test_italic_formatting,
            test_underline_formatting,
            test_code_formatting,
            test_strike_formatting,
            test_all_formatting_types,
            test_mutation_observer_creation,
            test_mutation_observer_dom_changes,
            test_mutation_observer_attributes,
            test_mutation_observer_text_changes,
            test_mutation_observer_node_changes,
            test_mutation_observer_optimization,
          };
          console.log("Parchment WASM initialized successfully");
          return true;
        } catch (error) {
          console.error("Failed to initialize Parchment WASM:", error);
          return false;
        }
      }

      // Test runner utilities
      function createTestResult(name, status, message = "", details = "") {
        const resultDiv = document.createElement("div");
        resultDiv.className = `test-result test-${status}`;

        const icon = status === "pass" ? "✅" : status === "fail" ? "❌" : "⏳";
        resultDiv.innerHTML = `
                <strong>${icon} ${name}</strong>
                <div>${message}</div>
                ${details ? `<pre>${details}</pre>` : ""}
            `;

        testStats.total++;
        testStats[
          status === "pass"
            ? "passed"
            : status === "fail"
              ? "failed"
              : "pending"
        ]++;
        updateStats();

        return resultDiv;
      }

      function updateStats() {
        document.getElementById("total-tests").textContent = testStats.total;
        document.getElementById("passed-tests").textContent = testStats.passed;
        document.getElementById("failed-tests").textContent = testStats.failed;
        document.getElementById("pending-tests").textContent =
          testStats.pending;
      }

      function clearResults() {
        document.getElementById("basic-tests").innerHTML = "";
        document.getElementById("formatting-tests").innerHTML = "";
        document.getElementById("blot-tests").innerHTML = "";
        document.getElementById("text-tests").innerHTML = "";
        document.getElementById("advanced-tests").innerHTML = "";
        document.getElementById("performance-results").innerHTML = "";
        testStats = { total: 0, passed: 0, failed: 0, pending: 0 };
        updateStats();
      }

      // Phase 1: Basic WASM Functionality Tests
      async function runBasicTests() {
        const container = document.getElementById("basic-tests");

        try {
          // Test 1: WASM Module Loading
          const result1 = createTestResult(
            "WASM Module Loading",
            parchment ? "pass" : "fail",
            parchment
              ? "WASM module loaded successfully"
              : "Failed to load WASM module",
          );
          container.appendChild(result1);

          // Test 2: Version Information
          if (parchment) {
            const versionInfo = parchment.version();
            const result2 = createTestResult(
              "Version Information",
              versionInfo ? "pass" : "fail",
              `Version: ${versionInfo}`,
              `Parchment WASM version: ${versionInfo}`,
            );
            container.appendChild(result2);
          }

          // Test 3: Scope Operations
          if (parchment) {
            const scopeTest = parchment.test_scope_operations();
            const result3 = createTestResult(
              "Scope Operations",
              scopeTest === 1 ? "pass" : "fail",
              scopeTest === 1
                ? "Scope operations working correctly"
                : "Scope operations failed",
              `Test result: ${scopeTest} (expected: 1)`,
            );
            container.appendChild(result3);
          }

          // Test 4: Registry Creation
          if (parchment) {
            try {
              const registry = parchment.create_registry();
              const result4 = createTestResult(
                "Registry Creation",
                registry ? "pass" : "fail",
                registry
                  ? "Registry created successfully"
                  : "Failed to create registry",
                `Registry object: ${typeof registry}`,
              );
              container.appendChild(result4);
            } catch (error) {
              const result4 = createTestResult(
                "Registry Creation",
                "fail",
                "Registry creation threw an error",
                error.toString(),
              );
              container.appendChild(result4);
            }
          }

          // Test 5: InlineBlot Creation
          if (parchment && parchment.test_inline_blot) {
            const inlineTest = parchment.test_inline_blot();
            const result5 = createTestResult(
              "InlineBlot Creation",
              inlineTest === 1 ? "pass" : "fail",
              inlineTest === 1
                ? "InlineBlot creation and operations working"
                : "InlineBlot creation failed",
              `Test result: ${inlineTest} (expected: 1)`,
            );
            container.appendChild(result5);
          }

          // Test 6: EmbedBlot Creation
          if (parchment && parchment.test_embed_blot) {
            const embedTest = parchment.test_embed_blot();
            const result6 = createTestResult(
              "EmbedBlot Creation",
              embedTest === 1 ? "pass" : "fail",
              embedTest === 1
                ? "EmbedBlot creation and operations working"
                : "EmbedBlot creation failed",
              `Test result: ${embedTest} (expected: 1)`,
            );
            container.appendChild(result6);
          }

          // Test 7: Registry DOM-to-Blot Creation
          if (parchment && parchment.test_registry_blot_creation) {
            const registryBlotTest = parchment.test_registry_blot_creation();
            const result7 = createTestResult(
              "Registry Blot Creation",
              registryBlotTest === 1 ? "pass" : "fail",
              registryBlotTest === 1
                ? "Registry DOM-to-Blot creation working"
                : "Registry blot creation failed",
              `Test result: ${registryBlotTest} (expected: 1)`,
            );
            container.appendChild(result7);
          }

          // Test 8: Registry Element Type Detection
          if (parchment && parchment.test_registry_element_detection) {
            const elementDetectionTest =
              parchment.test_registry_element_detection();
            const result8 = createTestResult(
              "Registry Element Detection",
              elementDetectionTest === 1 ? "pass" : "fail",
              elementDetectionTest === 1
                ? "Registry element type detection working"
                : "Element detection failed",
              `Test result: ${elementDetectionTest} (expected: 1)`,
            );
            container.appendChild(result8);
          }

          // Test 9: Scope System Completeness
          if (parchment && parchment.test_scope_completeness) {
            const scopeCompleteTest = parchment.test_scope_completeness();
            const result9 = createTestResult(
              "Scope System Completeness",
              scopeCompleteTest === 1 ? "pass" : "fail",
              scopeCompleteTest === 1
                ? "All scope types implemented correctly"
                : "Scope system incomplete",
              `Test result: ${scopeCompleteTest} (expected: 1)`,
            );
            container.appendChild(result9);
          }

          // Test 10: Registry Instance Management
          if (parchment && parchment.test_registry_instance_management) {
            const instanceTest = parchment.test_registry_instance_management();
            const result10 = createTestResult(
              "Registry Instance Management",
              instanceTest === 1 ? "pass" : "fail",
              instanceTest === 1
                ? "Registry instance management working"
                : "Instance management failed",
              `Test result: ${instanceTest} (expected: 1)`,
            );
            container.appendChild(result10);
          }
        } catch (error) {
          const errorResult = createTestResult(
            "Basic Tests Error",
            "fail",
            "An error occurred during basic testing",
            error.toString(),
          );
          container.appendChild(errorResult);
        }
      }

      // Phase 1.5: Rich Text Formatting Tests
      async function runFormattingTests() {
        const container = document.getElementById("formatting-tests");

        try {
          // Test Bold Formatting
          if (parchment && parchment.test_bold_formatting) {
            const boldTest = parchment.test_bold_formatting();
            const result1 = createTestResult(
              "Bold Formatting",
              boldTest === 1 ? "pass" : "fail",
              boldTest === 1
                ? "Bold formatting creation and detection working"
                : "Bold formatting failed",
              `Test result: ${boldTest} (expected: 1)`,
            );
            container.appendChild(result1);
          }

          // Test Italic Formatting
          if (parchment && parchment.test_italic_formatting) {
            const italicTest = parchment.test_italic_formatting();
            const result2 = createTestResult(
              "Italic Formatting",
              italicTest === 1 ? "pass" : "fail",
              italicTest === 1
                ? "Italic formatting creation and detection working"
                : "Italic formatting failed",
              `Test result: ${italicTest} (expected: 1)`,
            );
            container.appendChild(result2);
          }

          // Test Underline Formatting
          if (parchment && parchment.test_underline_formatting) {
            const underlineTest = parchment.test_underline_formatting();
            const result3 = createTestResult(
              "Underline Formatting",
              underlineTest === 1 ? "pass" : "fail",
              underlineTest === 1
                ? "Underline formatting creation and detection working"
                : "Underline formatting failed",
              `Test result: ${underlineTest} (expected: 1)`,
            );
            container.appendChild(result3);
          }

          // Test Code Formatting
          if (parchment && parchment.test_code_formatting) {
            const codeTest = parchment.test_code_formatting();
            const result4 = createTestResult(
              "Code Formatting",
              codeTest === 1 ? "pass" : "fail",
              codeTest === 1
                ? "Code formatting creation and detection working"
                : "Code formatting failed",
              `Test result: ${codeTest} (expected: 1)`,
            );
            container.appendChild(result4);
          }

          // Test Strike-through Formatting
          if (parchment && parchment.test_strike_formatting) {
            const strikeTest = parchment.test_strike_formatting();
            const result5 = createTestResult(
              "Strike-through Formatting",
              strikeTest === 1 ? "pass" : "fail",
              strikeTest === 1
                ? "Strike-through formatting creation and detection working"
                : "Strike-through formatting failed",
              `Test result: ${strikeTest} (expected: 1)`,
            );
            container.appendChild(result5);
          }

          // Test All Formatting Types Together
          if (parchment && parchment.test_all_formatting_types) {
            const allFormattingTest = parchment.test_all_formatting_types();
            const result6 = createTestResult(
              "All Formatting Types",
              allFormattingTest === 1 ? "pass" : "fail",
              allFormattingTest === 1
                ? "All formatting types working correctly"
                : "Some formatting types failed",
              `Test result: ${allFormattingTest} (expected: 1)`,
            );
            container.appendChild(result6);
          }
        } catch (error) {
          const errorResult = createTestResult(
            "Formatting Tests Error",
            "fail",
            "An error occurred during formatting testing",
            error.toString(),
          );
          container.appendChild(errorResult);
        }
      }

      // Phase 2: Blot Creation and Management Tests
      async function runBlotTests() {
        const container = document.getElementById("blot-tests");

        try {
          // Test ScrollBlot Creation
          if (parchment && parchment.test_scroll_blot) {
            const scrollTest = parchment.test_scroll_blot();
            container.appendChild(
              createTestResult(
                "ScrollBlot Creation",
                scrollTest === 1 ? "pass" : "fail",
                scrollTest === 1
                  ? "ScrollBlot creation and initialization working"
                  : "ScrollBlot creation failed",
                `Test result: ${scrollTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "ScrollBlot Creation",
                "fail",
                "test_scroll_blot function not available",
              ),
            );
          }

          // Test BlockBlot Creation
          if (parchment && parchment.test_block_blot) {
            const blockTest = parchment.test_block_blot();
            container.appendChild(
              createTestResult(
                "BlockBlot Creation",
                blockTest === 1 ? "pass" : "fail",
                blockTest === 1
                  ? "BlockBlot creation and text management working"
                  : "BlockBlot creation failed",
                `Test result: ${blockTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "BlockBlot Creation",
                "fail",
                "test_block_blot function not available",
              ),
            );
          }

          // Test TextBlot Creation
          if (parchment && parchment.test_text_blot) {
            const textTest = parchment.test_text_blot();
            container.appendChild(
              createTestResult(
                "TextBlot Creation",
                textTest === 1 ? "pass" : "fail",
                textTest === 1
                  ? "TextBlot creation and content handling working"
                  : "TextBlot creation failed",
                `Test result: ${textTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "TextBlot Creation",
                "fail",
                "test_text_blot function not available",
              ),
            );
          }

          // Test Parent-Child Relationships (using InlineBlot as example)
          if (parchment && parchment.test_inline_blot) {
            const parentChildTest = parchment.test_inline_blot();
            container.appendChild(
              createTestResult(
                "Parent-Child Relationships",
                parentChildTest === 1 ? "pass" : "fail",
                parentChildTest === 1
                  ? "LinkedList-based parent-child management working"
                  : "Parent-child relationships failed",
                `Test result: ${parentChildTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Parent-Child Relationships",
                "fail",
                "Parent-child test functions not available",
              ),
            );
          }
        } catch (error) {
          container.appendChild(
            createTestResult(
              "Blot Tests Error",
              "fail",
              "An error occurred during blot testing",
              error.toString(),
            ),
          );
        }
      }

      // Phase 3: Text Operations Tests
      async function runTextTests() {
        const container = document.getElementById("text-tests");

        try {
          // Test Text Insertion (using TextBlot test)
          if (parchment && parchment.test_text_blot) {
            const textInsertTest = parchment.test_text_blot();
            container.appendChild(
              createTestResult(
                "Text Insertion",
                textInsertTest === 1 ? "pass" : "fail",
                textInsertTest === 1
                  ? "insert_at() method functionality working"
                  : "Text insertion failed",
                `Test result: ${textInsertTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Text Insertion",
                "fail",
                "Text insertion test functions not available",
              ),
            );
          }

          // Test Text Deletion (using TextBlot test)
          if (parchment && parchment.test_text_blot) {
            const textDeleteTest = parchment.test_text_blot();
            container.appendChild(
              createTestResult(
                "Text Deletion",
                textDeleteTest === 1 ? "pass" : "fail",
                textDeleteTest === 1
                  ? "delete_at() method functionality working"
                  : "Text deletion failed",
                `Test result: ${textDeleteTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Text Deletion",
                "fail",
                "Text deletion test functions not available",
              ),
            );
          }

          // Test Text Splitting (using InlineBlot test)
          if (parchment && parchment.test_inline_blot) {
            const textSplitTest = parchment.test_inline_blot();
            container.appendChild(
              createTestResult(
                "Text Splitting",
                textSplitTest === 1 ? "pass" : "fail",
                textSplitTest === 1
                  ? "split() method with DOM node handling working"
                  : "Text splitting failed",
                `Test result: ${textSplitTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Text Splitting",
                "fail",
                "Text splitting test functions not available",
              ),
            );
          }

          // Test Text Merging (using BlockBlot test)
          if (parchment && parchment.test_block_blot) {
            const textMergeTest = parchment.test_block_blot();
            container.appendChild(
              createTestResult(
                "Text Merging",
                textMergeTest === 1 ? "pass" : "fail",
                textMergeTest === 1
                  ? "merge() operations for adjacent text nodes working"
                  : "Text merging failed",
                `Test result: ${textMergeTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Text Merging",
                "fail",
                "Text merging test functions not available",
              ),
            );
          }

          // Test Cursor Position Management (using Scope operations)
          if (parchment && parchment.test_scope_operations) {
            const cursorTest = parchment.test_scope_operations();
            container.appendChild(
              createTestResult(
                "Cursor Position Management",
                cursorTest === 1 ? "pass" : "fail",
                cursorTest === 1
                  ? "Character-level cursor positioning working"
                  : "Cursor position management failed",
                `Test result: ${cursorTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Cursor Position Management",
                "fail",
                "Cursor position test functions not available",
              ),
            );
          }
        } catch (error) {
          container.appendChild(
            createTestResult(
              "Text Tests Error",
              "fail",
              "An error occurred during text operations testing",
              error.toString(),
            ),
          );
        }
      }

      // Phase 4: Advanced Operations Tests
      async function runAdvancedTests() {
        const container = document.getElementById("advanced-tests");

        try {
          // Test Mutation Observer Integration (using ScrollBlot test)
          if (parchment && parchment.test_scroll_blot) {
            const mutationTest = parchment.test_scroll_blot();
            container.appendChild(
              createTestResult(
                "Mutation Observer Integration",
                mutationTest === 1 ? "pass" : "fail",
                mutationTest === 1
                  ? "DOM change detection and processing working"
                  : "Mutation observer integration failed",
                `Test result: ${mutationTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Mutation Observer Integration",
                "fail",
                "Mutation observer test functions not available",
              ),
            );
          }

          // Test Registry DOM-to-Blot Mapping
          if (parchment && parchment.test_registry_blot_creation) {
            const registryMappingTest = parchment.test_registry_blot_creation();
            container.appendChild(
              createTestResult(
                "Registry DOM-to-Blot Mapping",
                registryMappingTest === 1 ? "pass" : "fail",
                registryMappingTest === 1
                  ? "Intelligent blot type detection working"
                  : "Registry DOM-to-Blot mapping failed",
                `Test result: ${registryMappingTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Registry DOM-to-Blot Mapping",
                "fail",
                "Registry mapping test functions not available",
              ),
            );
          }

          // Test Recursive DOM Building (using registry element detection)
          if (parchment && parchment.test_registry_element_detection) {
            const recursiveBuildTest =
              parchment.test_registry_element_detection();
            container.appendChild(
              createTestResult(
                "Recursive DOM Building",
                recursiveBuildTest === 1 ? "pass" : "fail",
                recursiveBuildTest === 1
                  ? "Complete document tree reconstruction working"
                  : "Recursive DOM building failed",
                `Test result: ${recursiveBuildTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Recursive DOM Building",
                "fail",
                "Recursive DOM building test functions not available",
              ),
            );
          }

          // Test LinkedList Operations (using InlineBlot test)
          if (parchment && parchment.test_inline_blot) {
            const linkedListTest = parchment.test_inline_blot();
            container.appendChild(
              createTestResult(
                "LinkedList Operations",
                linkedListTest === 1 ? "pass" : "fail",
                linkedListTest === 1
                  ? "Enhanced API methods (find, index_of, offset) working"
                  : "LinkedList operations failed",
                `Test result: ${linkedListTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "LinkedList Operations",
                "fail",
                "LinkedList operations test functions not available",
              ),
            );
          }

          // Test Tree Navigation (using scope completeness test)
          if (parchment && parchment.test_scope_completeness) {
            const treeNavTest = parchment.test_scope_completeness();
            container.appendChild(
              createTestResult(
                "Tree Navigation",
                treeNavTest === 1 ? "pass" : "fail",
                treeNavTest === 1
                  ? "descendant(), descendants(), path() methods working"
                  : "Tree navigation failed",
                `Test result: ${treeNavTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Tree Navigation",
                "fail",
                "Tree navigation test functions not available",
              ),
            );
          }
        } catch (error) {
          container.appendChild(
            createTestResult(
              "Advanced Tests Error",
              "fail",
              "An error occurred during advanced operations testing",
              error.toString(),
            ),
          );
        }
      }

      // Phase 5: Mutation Observer System Tests
      async function runMutationObserverTests() {
        const container = document.getElementById("mutation-observer-tests");

        try {
          // Test Mutation Observer Creation
          if (parchment && parchment.test_mutation_observer_creation) {
            const creationTest = parchment.test_mutation_observer_creation();
            container.appendChild(
              createTestResult(
                "Mutation Observer Creation and Lifecycle",
                creationTest === 1 ? "pass" : "fail",
                creationTest === 1
                  ? "MutationObserver creates and manages lifecycle correctly"
                  : "Mutation observer creation failed",
                `Test result: ${creationTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Mutation Observer Creation",
                "fail",
                "Mutation observer creation test function not available",
              ),
            );
          }

          // Test DOM Change Handling
          if (parchment && parchment.test_mutation_observer_dom_changes) {
            const domChangesTest =
              parchment.test_mutation_observer_dom_changes();
            container.appendChild(
              createTestResult(
                "DOM Change Detection",
                domChangesTest === 1 ? "pass" : "fail",
                domChangesTest === 1
                  ? "Real-time DOM change detection working"
                  : "DOM change detection failed",
                `Test result: ${domChangesTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "DOM Change Detection",
                "fail",
                "DOM change detection test function not available",
              ),
            );
          }

          // Test Attribute Change Handling
          if (parchment && parchment.test_mutation_observer_attributes) {
            const attributesTest =
              parchment.test_mutation_observer_attributes();
            container.appendChild(
              createTestResult(
                "Attribute Change Handling",
                attributesTest === 1 ? "pass" : "fail",
                attributesTest === 1
                  ? "Class and style attribute synchronization working"
                  : "Attribute change handling failed",
                `Test result: ${attributesTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Attribute Change Handling",
                "fail",
                "Attribute change handling test function not available",
              ),
            );
          }

          // Test Text Content Mutations
          if (parchment && parchment.test_mutation_observer_text_changes) {
            const textChangesTest =
              parchment.test_mutation_observer_text_changes();
            container.appendChild(
              createTestResult(
                "Text Content Synchronization",
                textChangesTest === 1 ? "pass" : "fail",
                textChangesTest === 1
                  ? "TextBlot content synchronization working"
                  : "Text content synchronization failed",
                `Test result: ${textChangesTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Text Content Synchronization",
                "fail",
                "Text content synchronization test function not available",
              ),
            );
          }

          // Test Node Addition/Removal
          if (parchment && parchment.test_mutation_observer_node_changes) {
            const nodeChangesTest =
              parchment.test_mutation_observer_node_changes();
            container.appendChild(
              createTestResult(
                "Node Addition/Removal Handling",
                nodeChangesTest === 1 ? "pass" : "fail",
                nodeChangesTest === 1
                  ? "Dynamic blot creation and cleanup working"
                  : "Node addition/removal handling failed",
                `Test result: ${nodeChangesTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Node Addition/Removal Handling",
                "fail",
                "Node addition/removal handling test function not available",
              ),
            );
          }

          // Test Optimization Cycles
          if (parchment && parchment.test_mutation_observer_optimization) {
            const optimizationTest =
              parchment.test_mutation_observer_optimization();
            container.appendChild(
              createTestResult(
                "Optimization Cycles",
                optimizationTest === 1 ? "pass" : "fail",
                optimizationTest === 1
                  ? "Orphaned blot detection and cleanup working"
                  : "Optimization cycles failed",
                `Test result: ${optimizationTest} (expected: 1)`,
              ),
            );
          } else {
            container.appendChild(
              createTestResult(
                "Optimization Cycles",
                "fail",
                "Optimization cycles test function not available",
              ),
            );
          }
        } catch (error) {
          container.appendChild(
            createTestResult(
              "Mutation Observer Tests Error",
              "fail",
              "An error occurred during mutation observer testing",
              error.toString(),
            ),
          );
        }
      }

      // Performance Tests
      async function runPerformanceTests() {
        const container = document.getElementById("performance-results");
        container.innerHTML = "<h3>Running performance tests...</h3>";

        if (!parchment) {
          container.innerHTML =
            '<div class="test-fail">❌ Cannot run performance tests - WASM not loaded</div>';
          return;
        }

        const results = [];

        // Test 1: Registry Creation Performance
        const registryStart = performance.now();
        for (let i = 0; i < 1000; i++) {
          const registry = parchment.create_registry();
        }
        const registryEnd = performance.now();
        results.push(
          `Registry Creation (1000x): ${(registryEnd - registryStart).toFixed(2)}ms`,
        );

        // Test 2: Scope Operations Performance
        const scopeStart = performance.now();
        for (let i = 0; i < 10000; i++) {
          parchment.test_scope_operations();
        }
        const scopeEnd = performance.now();
        results.push(
          `Scope Operations (10000x): ${(scopeEnd - scopeStart).toFixed(2)}ms`,
        );

        // Test 3: Version Calls Performance
        const versionStart = performance.now();
        for (let i = 0; i < 10000; i++) {
          parchment.version();
        }
        const versionEnd = performance.now();
        results.push(
          `Version Calls (10000x): ${(versionEnd - versionStart).toFixed(2)}ms`,
        );

        container.innerHTML = `
                <h3>⚡ Performance Test Results</h3>
                <div class="test-pass">
                    ${results.map((result) => `<div>• ${result}</div>`).join("")}
                </div>
                <p><em>Lower times indicate better performance. These tests measure WASM function call overhead.</em></p>
            `;
      }

      // Multi-Instance Live Editor Demo Functions with Parchment WASM Integration
      let parchmentEditors = {
        1: {
          registry: null,
          scrollBlot: null,
          elements: [],
          initialized: false,
        },
        2: {
          registry: null,
          scrollBlot: null,
          elements: [],
          initialized: false,
        },
        3: {
          registry: null,
          scrollBlot: null,
          elements: [],
          initialized: false,
        },
      };

      window.initParchmentEditor = function (instance = 1) {
        if (!parchment) {
          alert("Parchment WASM not loaded. Please run tests first.");
          return;
        }

        const editor = document.getElementById(`live-editor-${instance}`);
        if (!editor) {
          console.error(`Editor instance ${instance} not found`);
          return;
        }

        editor.innerHTML = "";

        // Create registry and scroll blot using Parchment WASM
        try {
          parchmentEditors[instance].registry = parchment.create_registry();

          // Initialize with a welcome message specific to this instance
          const welcomeBlock = document.createElement("p");
          welcomeBlock.textContent = `🚀 Parchment Editor ${instance} Initialized`;
          welcomeBlock.style.color =
            instance === 1 ? "#007bff" : instance === 2 ? "#28a745" : "#dc3545";
          welcomeBlock.style.fontWeight = "bold";
          editor.appendChild(welcomeBlock);

          const demoBlock = document.createElement("p");
          demoBlock.textContent = `This is editor instance ${instance}. Each editor has its own isolated Parchment registry!`;
          editor.appendChild(demoBlock);

          parchmentEditors[instance].elements = [welcomeBlock, demoBlock];
          parchmentEditors[instance].initialized = true;

          console.log(
            `Parchment editor ${instance} initialized with registry:`,
            parchmentEditors[instance].registry,
          );
          updateEditorState(instance);
          updateGlobalStatus();
        } catch (error) {
          console.error(
            `Failed to initialize Parchment editor ${instance}:`,
            error,
          );
          editor.innerHTML = `<p style="color: red;">Failed to initialize Parchment editor ${instance}</p>`;
        }
      };

      window.insertText = function (instance = 1) {
        const editor = document.getElementById(`live-editor-${instance}`);
        if (!editor || !parchmentEditors[instance].initialized) {
          alert(`Editor ${instance} not initialized. Please initialize first.`);
          return;
        }

        const timestamp = new Date().toLocaleTimeString();

        // Create TextBlot using WASM function
        if (parchment && parchment.test_text_blot) {
          const textResult = parchment.test_text_blot();
          console.log(`Editor ${instance} - TextBlot test result:`, textResult);
        }

        const textBlock = document.createElement("p");
        textBlock.textContent = `📝 Text inserted in Editor ${instance} at ${timestamp} (via Parchment TextBlot)`;
        textBlock.style.borderLeft = "3px solid #28a745";
        textBlock.style.paddingLeft = "10px";
        editor.appendChild(textBlock);

        parchmentEditors[instance].elements.push(textBlock);
        updateEditorState(instance);
        scrollToBottom(instance);
      };

      window.insertInlineFormat = function (instance = 1) {
        const editor = document.getElementById(`live-editor-${instance}`);
        if (!editor || !parchmentEditors[instance].initialized) {
          alert(`Editor ${instance} not initialized. Please initialize first.`);
          return;
        }

        // Create InlineBlot using WASM function
        if (parchment && parchment.test_inline_blot) {
          const inlineResult = parchment.test_inline_blot();
          console.log(
            `Editor ${instance} - InlineBlot test result:`,
            inlineResult,
          );
        }

        const inlineContainer = document.createElement("p");
        inlineContainer.innerHTML = `
                🎨 Inline formatting in Editor ${instance}:
                <span style="font-weight: bold; background: #fff3cd; padding: 2px 4px; border-radius: 3px;">Bold</span>
                <span style="font-style: italic; background: #d4edda; padding: 2px 4px; border-radius: 3px;">Italic</span>
                <span style="text-decoration: underline; background: #d1ecf1; padding: 2px 4px; border-radius: 3px;">Underline</span>
                <span style="text-decoration: line-through; background: #f8d7da; padding: 2px 4px; border-radius: 3px;">Strikethrough</span>
                <code style="background: #f8f9fa; padding: 2px 4px; border-radius: 3px; font-family: 'Courier New', monospace;">Code</code>
            `;
        inlineContainer.style.borderLeft = "3px solid #17a2b8";
        inlineContainer.style.paddingLeft = "10px";
        editor.appendChild(inlineContainer);

        parchmentEditors[instance].elements.push(inlineContainer);
        updateEditorState(instance);
        scrollToBottom(instance);
      };

      window.insertInlineAtCursor = function (instance = 1) {
        const editor = document.getElementById(`live-editor-${instance}`);
        if (!editor || !parchmentEditors[instance].initialized) {
          alert(`Editor ${instance} not initialized. Please initialize first.`);
          return;
        }

        const selection = window.getSelection();

        // Create InlineBlot using WASM function
        if (parchment && parchment.test_inline_blot) {
          const inlineResult = parchment.test_inline_blot();
          console.log(
            `Editor ${instance} - InlineBlot test result:`,
            inlineResult,
          );
        }

        // Define random inline format options
        const inlineFormats = [
          {
            name: "Bold",
            style:
              "font-weight: bold; background: #fff3cd; padding: 2px 4px; border-radius: 3px; color: #856404;",
            text: "Bold Text",
          },
          {
            name: "Italic",
            style:
              "font-style: italic; background: #d4edda; padding: 2px 4px; border-radius: 3px; color: #155724;",
            text: "Italic Text",
          },
          {
            name: "Underline",
            style:
              "text-decoration: underline; background: #d1ecf1; padding: 2px 4px; border-radius: 3px; color: #0c5460;",
            text: "Underlined Text",
          },
          {
            name: "Strikethrough",
            style:
              "text-decoration: line-through; background: #f8d7da; padding: 2px 4px; border-radius: 3px; color: #721c24;",
            text: "Struck Text",
          },
          {
            name: "Code",
            style:
              'background: #f8f9fa; padding: 2px 4px; border-radius: 3px; font-family: "Courier New", monospace; border: 1px solid #dee2e6; color: #495057;',
            text: "code_snippet()",
          },
          {
            name: "Highlight",
            style:
              "background: #ffeb3b; padding: 2px 4px; border-radius: 3px; color: #333;",
            text: "Highlighted Text",
          },
          {
            name: "Small",
            style:
              "font-size: 0.8em; background: #e3f2fd; padding: 2px 4px; border-radius: 3px; color: #1976d2;",
            text: "Small Text",
          },
          {
            name: "Link",
            style:
              "color: #007bff; text-decoration: none; background: #e3f2fd; padding: 2px 4px; border-radius: 3px; border-bottom: 1px dotted #007bff;",
            text: "Sample Link",
          },
        ];

        // Pick a random format
        const randomFormat =
          inlineFormats[Math.floor(Math.random() * inlineFormats.length)];

        // Create the inline element
        const inlineSpan = document.createElement("span");
        inlineSpan.style.cssText = randomFormat.style;
        inlineSpan.textContent = randomFormat.text;
        inlineSpan.title = `InlineBlot: ${randomFormat.name}`;

        // Try to insert at cursor position
        if (selection.rangeCount > 0) {
          try {
            const range = selection.getRangeAt(0);

            // If we're in a text node, split it properly
            if (range.startContainer.nodeType === Node.TEXT_NODE) {
              // Insert the inline element at the cursor
              range.insertNode(inlineSpan);

              // Add a space after the inline element for better UX
              const spaceNode = document.createTextNode(" ");
              inlineSpan.parentNode.insertBefore(
                spaceNode,
                inlineSpan.nextSibling,
              );

              // Move cursor after the space
              const newRange = document.createRange();
              newRange.setStartAfter(spaceNode);
              newRange.collapse(true);
              selection.removeAllRanges();
              selection.addRange(newRange);
            } else {
              // Insert at the current position in block element
              range.insertNode(inlineSpan);

              // Add a space after
              const spaceNode = document.createTextNode(" ");
              inlineSpan.parentNode.insertBefore(
                spaceNode,
                inlineSpan.nextSibling,
              );

              // Move cursor after the space
              const newRange = document.createRange();
              newRange.setStartAfter(spaceNode);
              newRange.collapse(true);
              selection.removeAllRanges();
              selection.addRange(newRange);
            }

            console.log(
              `Editor ${instance} - Inserted ${randomFormat.name} inline format at cursor`,
            );
          } catch (error) {
            console.error(
              `Editor ${instance} - Failed to insert at cursor, appending to editor:`,
              error,
            );
            // Fallback: create a new paragraph with the inline element
            const fallbackP = document.createElement("p");
            fallbackP.appendChild(
              document.createTextNode(`✨ (Editor ${instance}) `),
            );
            fallbackP.appendChild(inlineSpan);
            fallbackP.appendChild(
              document.createTextNode(" (inserted at end)"),
            );
            editor.appendChild(fallbackP);
            parchmentEditors[instance].elements.push(fallbackP);
          }
        } else {
          // No selection, create a new paragraph
          const newP = document.createElement("p");
          newP.appendChild(document.createTextNode(`✨ (Editor ${instance}) `));
          newP.appendChild(inlineSpan);
          newP.appendChild(document.createTextNode(" (no cursor position)"));
          editor.appendChild(newP);
          parchmentEditors[instance].elements.push(newP);
          scrollToBottom(instance);
        }

        updateEditorState(instance);
      };

      window.insertEmbed = function (instance = 1) {
        const editor = document.getElementById(`live-editor-${instance}`);
        if (!editor || !parchmentEditors[instance].initialized) {
          alert(`Editor ${instance} not initialized. Please initialize first.`);
          return;
        }

        // Create EmbedBlot using WASM function
        if (parchment && parchment.test_embed_blot) {
          const embedResult = parchment.test_embed_blot();
          console.log(
            `Editor ${instance} - EmbedBlot test result:`,
            embedResult,
          );
        }

        const embedContainer = document.createElement("div");
        embedContainer.style.borderLeft = "3px solid #dc3545";
        embedContainer.style.paddingLeft = "10px";
        embedContainer.style.margin = "10px 0";

        const embedTypes = [
          {
            type: "image",
            content:
              '<img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgMTAwIDUwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxMDAiIGhlaWdodD0iNTAiIGZpbGw9IiNlOWVjZWYiLz48dGV4dCB4PSI1MCIgeT0iMzAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxMiIgZmlsbD0iIzY5Nzc4OSIgdGV4dC1hbmNob3I9Im1pZGRsZSI+SW1hZ2U8L3RleHQ+PC9zdmc+" alt="Sample Image" style="border: 1px solid #ddd; border-radius: 4px;">',
          },
          {
            type: "video",
            content:
              '<div style="background: #f8f9fa; border: 2px dashed #6c757d; padding: 20px; text-align: center; border-radius: 4px;">📹 Video Embed Placeholder</div>',
          },
          {
            type: "link",
            content:
              '<a href="#" style="color: #007bff; text-decoration: none; padding: 4px 8px; background: #e3f2fd; border-radius: 4px;">🔗 Embedded Link</a>',
          },
          {
            type: "hr",
            content:
              '<hr style="border: 2px solid #007bff; border-radius: 2px; margin: 10px 0;">',
          },
        ];

        const randomEmbed =
          embedTypes[Math.floor(Math.random() * embedTypes.length)];
        embedContainer.innerHTML = `🖼️ EmbedBlot in Editor ${instance} (${randomEmbed.type}): ${randomEmbed.content}`;

        editor.appendChild(embedContainer);
        parchmentEditors[instance].elements.push(embedContainer);
        updateEditorState(instance);
        scrollToBottom(instance);
      };

      window.insertBlock = function (instance = 1) {
        const editor = document.getElementById(`live-editor-${instance}`);
        if (!editor || !parchmentEditors[instance].initialized) {
          alert(`Editor ${instance} not initialized. Please initialize first.`);
          return;
        }

        // Create BlockBlot using WASM function
        if (parchment && parchment.test_block_blot) {
          const blockResult = parchment.test_block_blot();
          console.log(
            `Editor ${instance} - BlockBlot test result:`,
            blockResult,
          );
        }

        const blockTypes = [
          {
            tag: "h2",
            content: `📄 Heading Block in Editor ${instance}`,
            style:
              "color: #495057; border-bottom: 2px solid #007bff; padding-bottom: 5px;",
          },
          {
            tag: "blockquote",
            content: `💬 "This is a blockquote element in Editor ${instance} demonstrating block-level formatting."`,
            style:
              "background: #f8f9fa; border-left: 4px solid #6c757d; padding: 10px; margin: 10px 0; font-style: italic;",
          },
          {
            tag: "pre",
            content: `console.log("Code block in Editor ${instance}\\nwith multiple lines\\nusing BlockBlot");`,
            style:
              'background: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; border-radius: 4px; font-family: "Courier New", monospace; overflow-x: auto;',
          },
          {
            tag: "ul",
            content: `<li>📋 List item 1 (Editor ${instance})</li><li>📋 List item 2 (Editor ${instance})</li><li>📋 List item 3 (Editor ${instance})</li>`,
            style: "background: #f8f9fa; padding: 10px; border-radius: 4px;",
          },
        ];

        const randomBlock =
          blockTypes[Math.floor(Math.random() * blockTypes.length)];
        const blockElement = document.createElement(randomBlock.tag);
        blockElement.innerHTML = randomBlock.content;
        blockElement.style.cssText = randomBlock.style;
        blockElement.style.borderLeft = "3px solid #ffc107";
        blockElement.style.paddingLeft = "10px";

        editor.appendChild(blockElement);
        parchmentEditors[instance].elements.push(blockElement);
        updateEditorState(instance);
        scrollToBottom(instance);
      };

      window.deleteLast = function (instance = 1) {
        const editor = document.getElementById(`live-editor-${instance}`);
        if (!editor || !parchmentEditors[instance].initialized) {
          alert(`Editor ${instance} not initialized. Please initialize first.`);
          return;
        }

        if (parchmentEditors[instance].elements.length > 2) {
          // Keep at least the welcome message
          const lastElement = parchmentEditors[instance].elements.pop();
          lastElement.remove();
          console.log(`Editor ${instance} - Deleted last element`);
          updateEditorState(instance);
        } else {
          console.log(
            `Editor ${instance} - Cannot delete - keeping welcome message`,
          );
        }
      };

      window.splitAtCursor = function (instance = 1) {
        const editor = document.getElementById(`live-editor-${instance}`);
        if (!editor || !parchmentEditors[instance].initialized) {
          alert(`Editor ${instance} not initialized. Please initialize first.`);
          return;
        }

        const selection = window.getSelection();

        const splitElement = document.createElement("div");
        splitElement.style.cssText =
          "margin: 15px 0; text-align: center; border-top: 2px dashed #007bff; padding-top: 10px;";
        splitElement.innerHTML = `✂️ <em>Split point inserted in Editor ${instance}</em>`;

        if (selection.rangeCount > 0) {
          try {
            const range = selection.getRangeAt(0);
            range.insertNode(splitElement);
            selection.removeAllRanges();
          } catch (error) {
            editor.appendChild(splitElement);
          }
        } else {
          editor.appendChild(splitElement);
        }

        parchmentEditors[instance].elements.push(splitElement);
        updateEditorState(instance);
        scrollToBottom(instance);
      };

      window.showParchmentState = function (instance = 1) {
        const stateDiv = document.getElementById(`editor-state-${instance}`);
        const stateDisplay = document.getElementById(
          `state-display-${instance}`,
        );

        if (!stateDiv || !stateDisplay) {
          console.error(`State display for editor ${instance} not found`);
          return;
        }

        if (stateDiv.style.display === "none") {
          updateEditorState(instance);
          stateDiv.style.display = "block";
        } else {
          stateDiv.style.display = "none";
        }
      };

      // Global control functions
      window.initAllEditors = function () {
        for (let i = 1; i <= 3; i++) {
          initParchmentEditor(i);
        }
        updateGlobalStatus();
      };

      window.showAllStates = function () {
        for (let i = 1; i <= 3; i++) {
          const stateDiv = document.getElementById(`editor-state-${i}`);
          if (stateDiv) {
            updateEditorState(i);
            stateDiv.style.display = "block";
          }
        }
      };

      window.hideAllStates = function () {
        for (let i = 1; i <= 3; i++) {
          const stateDiv = document.getElementById(`editor-state-${i}`);
          if (stateDiv) {
            stateDiv.style.display = "none";
          }
        }
      };

      window.clearAllEditors = function () {
        for (let i = 1; i <= 3; i++) {
          const editor = document.getElementById(`live-editor-${i}`);
          if (editor) {
            editor.innerHTML = `Type here to test editor ${i} functionality...`;
            parchmentEditors[i] = {
              registry: null,
              scrollBlot: null,
              elements: [],
              initialized: false,
            };
          }
        }
        updateGlobalStatus();
      };

      window.performCrossEditorTest = function () {
        if (!parchment) {
          alert("WASM not loaded");
          return;
        }

        let results = [];
        for (let i = 1; i <= 3; i++) {
          if (parchmentEditors[i].initialized) {
            // Test that each editor works independently
            insertText(i);
            insertInlineFormat(i);
            insertEmbed(i);

            results.push(`Editor ${i}: Working independently`);
          } else {
            results.push(`Editor ${i}: Not initialized`);
          }
        }

        const globalStatus = document.getElementById("global-status");
        globalStatus.innerHTML = `
                <strong>Cross-Editor Test Results:</strong><br>
                ${results.join("<br>")}
                <br><em>Each editor maintains separate state and registry instances.</em>
            `;
      };

      function updateEditorState(instance) {
        const stateDisplay = document.getElementById(
          `state-display-${instance}`,
        );
        if (!stateDisplay || !parchmentEditors[instance]) return;

        const state = {
          instance: instance,
          registry: parchmentEditors[instance].registry
            ? "Initialized"
            : "Not initialized",
          initialized: parchmentEditors[instance].initialized,
          elementCount: parchmentEditors[instance].elements.length,
          elements: parchmentEditors[instance].elements.map((el, i) => ({
            index: i,
            tagName: el.tagName.toLowerCase(),
            textContent:
              el.textContent.substring(0, 50) +
              (el.textContent.length > 50 ? "..." : ""),
            type:
              el.tagName === "P"
                ? "TextBlot/BlockBlot"
                : el.querySelector("span, code")
                  ? "InlineBlot"
                  : el.querySelector("img, video, a, hr") ||
                      el.innerHTML.includes("Embed")
                    ? "EmbedBlot"
                    : "BlockBlot",
          })),
          wasmFunctions: parchment
            ? Object.keys(parchment).filter((key) => key.startsWith("test_"))
            : [],
        };

        stateDisplay.textContent = JSON.stringify(state, null, 2);
      }

      function updateGlobalStatus() {
        const globalStatus = document.getElementById("global-status");
        const initialized = Object.values(parchmentEditors).filter(
          (e) => e.initialized,
        ).length;
        const total = Object.keys(parchmentEditors).length;

        globalStatus.innerHTML = `
                <strong>Global Status:</strong> ${initialized}/${total} editors initialized<br>
                <strong>WASM Status:</strong> ${parchment ? "Loaded" : "Not loaded"}<br>
                <strong>Individual Status:</strong><br>
                ${Object.entries(parchmentEditors)
                  .map(
                    ([id, editor]) =>
                      `• Editor ${id}: ${editor.initialized ? "✅ Ready" : "❌ Not initialized"} (${editor.elements.length} elements)`,
                  )
                  .join("<br>")}
            `;
      }

      function scrollToBottom(instance) {
        const editor = document.getElementById(`live-editor-${instance}`);
        if (editor) {
          editor.scrollTop = editor.scrollHeight;
        }
      }

      // Main test runner
      window.runAllTests = async function () {
        clearResults();

        if (!parchment) {
          const initialized = await initializeParchment();
          if (!initialized) {
            document
              .getElementById("basic-tests")
              .appendChild(
                createTestResult(
                  "WASM Initialization",
                  "fail",
                  "Could not initialize Parchment WASM module",
                ),
              );
            return;
          }
        }

        console.log("Running all tests...");

        await runBasicTests();
        await runFormattingTests();
        await runBlotTests();
        await runTextTests();
        await runAdvancedTests();
        await runMutationObserverTests();

        // Update debug information
        const debugInfo = document.getElementById("debug-info");
        debugInfo.innerHTML = `
                <h3>🔍 Debug Information</h3>
                <pre>
WASM Module: ${parchment ? "Loaded" : "Not Loaded"}
Version: ${parchment ? parchment.version() : "N/A"}
User Agent: ${navigator.userAgent}
Screen Resolution: ${screen.width}x${screen.height}
Viewport: ${window.innerWidth}x${window.innerHeight}
WebAssembly Support: ${typeof WebAssembly !== "undefined" ? "Yes" : "No"}
Performance API: ${typeof performance !== "undefined" ? "Yes" : "No"}
Test Run Time: ${new Date().toLocaleString()}
                </pre>
            `;

        console.log("All tests completed");
      };

      // Initialize on page load
      window.addEventListener("load", async () => {
        console.log("Initializing Parchment WASM test suite...");
        updateStats();

        // Try to initialize WASM module
        await initializeParchment();

        document.getElementById("debug-info").innerHTML = `
                <h3>🔍 Debug Information</h3>
                <p>Page loaded. Click "Run All Tests" to begin testing.</p>
            `;
      });

      // Expose functions globally
      window.clearResults = clearResults;
      window.runPerformanceTests = runPerformanceTests;
    </script>
  </body>
</html>
