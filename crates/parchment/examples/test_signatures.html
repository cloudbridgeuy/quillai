<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Method Signature and Behavior Validation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-left: 4px solid #007acc;
        }
        .test-result {
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
        }
        .success { background-color: #d4edda; color: #155724; }
        .error { background-color: #f8d7da; color: #721c24; }
        .info { background-color: #d1ecf1; color: #0c5460; }
        .warning { background-color: #fff3cd; color: #856404; }
        .signature-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        .signature-table th, .signature-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .signature-table th {
            background-color: #f8f9fa;
        }
    </style>
</head>
<body>
    <h1>üîç Method Signature and Behavior Validation</h1>
    <p>Comprehensive validation of all method signatures and behavior consistency.</p>
    
    <div class="test-section">
        <h2>1. Constructor Signature Validation</h2>
        <div id="constructor-results"></div>
    </div>
    
    <div class="test-section">
        <h2>2. Method Signature Validation</h2>
        <div id="method-results"></div>
    </div>
    
    <div class="test-section">
        <h2>3. Return Type Validation</h2>
        <div id="return-results"></div>
    </div>
    
    <div class="test-section">
        <h2>4. Behavior Consistency Validation</h2>
        <div id="behavior-results"></div>
    </div>
    
    <div class="test-section">
        <h2>5. Edge Case Behavior</h2>
        <div id="edge-results"></div>
    </div>
    
    <div class="test-section">
        <h2>6. Cross-Attributor Consistency</h2>
        <div id="consistency-results"></div>
    </div>
    
    <script type="module">
        let Parchment;
        
        function logResult(containerId, message, type = 'info') {
            const container = document.getElementById(containerId);
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${type}`;
            resultDiv.textContent = message;
            container.appendChild(resultDiv);
        }
        
        function createTable(containerId, headers, rows) {
            const container = document.getElementById(containerId);
            const table = document.createElement('table');
            table.className = 'signature-table';
            
            // Create header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Create body
            const tbody = document.createElement('tbody');
            rows.forEach(row => {
                const tr = document.createElement('tr');
                row.forEach(cell => {
                    const td = document.createElement('td');
                    td.textContent = cell;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            
            container.appendChild(table);
        }
        
        async function runValidationTests() {
            try {
                // Initialize
                Parchment = await import('./pkg/quillai_parchment.js');
                await Parchment.default();
                
                logResult('constructor-results', 'üöÄ WASM initialized, starting validation...', 'info');
                
                // Test 1: Constructor Signature Validation
                logResult('constructor-results', 'üß™ Testing constructor signatures...', 'info');
                
                const constructorTests = [
                    {
                        name: 'Attributor',
                        basic: () => new Parchment.Attributor("test", "data-test"),
                        withScope: () => Parchment.Attributor.newWithScope("test", "data-test", Parchment.Scope.Inline),
                        withWhitelist: () => Parchment.Attributor.newWithWhitelist("test", "data-test", ["a", "b"]),
                        full: () => Parchment.Attributor.newFull("test", "data-test", Parchment.Scope.Block, ["x", "y"])
                    },
                    {
                        name: 'StyleAttributor',
                        basic: () => new Parchment.StyleAttributor("test", "color"),
                        withScope: () => Parchment.StyleAttributor.newWithScope("test", "color", Parchment.Scope.Inline),
                        withWhitelist: () => Parchment.StyleAttributor.newWithWhitelist("test", "color", ["red", "blue"]),
                        full: () => Parchment.StyleAttributor.newFull("test", "color", Parchment.Scope.Block, ["red", "blue"])
                    },
                    {
                        name: 'ClassAttributor',
                        basic: () => new Parchment.ClassAttributor("test", "text-align"),
                        withScope: () => Parchment.ClassAttributor.newWithScope("test", "text-align", Parchment.Scope.Inline),
                        withWhitelist: () => Parchment.ClassAttributor.newWithWhitelist("test", "text-align", ["left", "center"]),
                        full: () => Parchment.ClassAttributor.newFull("test", "text-align", Parchment.Scope.Block, ["left", "center"])
                    }
                ];
                
                const constructorRows = [];
                constructorTests.forEach(test => {
                    try {
                        const basic = test.basic();
                        const withScope = test.withScope();
                        const withWhitelist = test.withWhitelist();
                        const full = test.full();
                        
                        constructorRows.push([
                            test.name,
                            '‚úÖ Basic',
                            '‚úÖ WithScope',
                            '‚úÖ WithWhitelist',
                            '‚úÖ Full'
                        ]);
                        
                        logResult('constructor-results', `‚úÖ ${test.name} all constructors work`, 'success');
                    } catch (error) {
                        constructorRows.push([
                            test.name,
                            '‚ùå Error',
                            '‚ùå Error',
                            '‚ùå Error',
                            '‚ùå Error'
                        ]);
                        logResult('constructor-results', `‚ùå ${test.name} constructor error: ${error.message}`, 'error');
                    }
                });
                
                createTable('constructor-results', 
                    ['Attributor Type', 'Basic', 'WithScope', 'WithWhitelist', 'Full'],
                    constructorRows
                );
                
                // Test 2: Method Signature Validation
                logResult('method-results', 'üß™ Testing method signatures...', 'info');
                
                const element = document.createElement('div');
                const attr = new Parchment.Attributor("test", "data-test");
                const styleAttr = new Parchment.StyleAttributor("test", "color");
                const classAttr = new Parchment.ClassAttributor("test", "text-align");
                
                const methodTests = [
                    {
                        method: 'add',
                        test: (a) => a.add(element, "test"),
                        expectedType: 'boolean'
                    },
                    {
                        method: 'remove',
                        test: (a) => a.remove(element),
                        expectedType: 'undefined'
                    },
                    {
                        method: 'value',
                        test: (a) => a.value(element),
                        expectedType: 'string'
                    },
                    {
                        method: 'attrName',
                        test: (a) => a.attrName(),
                        expectedType: 'string'
                    },
                    {
                        method: 'keyName',
                        test: (a) => a.keyName(),
                        expectedType: 'string'
                    },
                    {
                        method: 'scope',
                        test: (a) => a.scope(),
                        expectedType: 'number'
                    }
                ];
                
                const methodRows = [];
                methodTests.forEach(test => {
                    try {
                        const result1 = test.test(attr);
                        const result2 = test.test(styleAttr);
                        const result3 = test.test(classAttr);
                        
                        const type1 = typeof result1;
                        const type2 = typeof result2;
                        const type3 = typeof result3;
                        
                        const match1 = type1 === test.expectedType ? '‚úÖ' : '‚ùå';
                        const match2 = type2 === test.expectedType ? '‚úÖ' : '‚ùå';
                        const match3 = type3 === test.expectedType ? '‚úÖ' : '‚ùå';
                        
                        methodRows.push([
                            test.method,
                            test.expectedType,
                            `${match1} ${type1}`,
                            `${match2} ${type2}`,
                            `${match3} ${type3}`
                        ]);
                        
                        if (type1 === test.expectedType && type2 === test.expectedType && type3 === test.expectedType) {
                            logResult('method-results', `‚úÖ ${test.method}() returns correct type: ${test.expectedType}`, 'success');
                        } else {
                            logResult('method-results', `‚ùå ${test.method}() type mismatch`, 'error');
                        }
                    } catch (error) {
                        methodRows.push([
                            test.method,
                            test.expectedType,
                            '‚ùå Error',
                            '‚ùå Error',
                            '‚ùå Error'
                        ]);
                        logResult('method-results', `‚ùå ${test.method}() error: ${error.message}`, 'error');
                    }
                });
                
                createTable('method-results',
                    ['Method', 'Expected Type', 'Attributor', 'StyleAttributor', 'ClassAttributor'],
                    methodRows
                );
                
                // Test 3: Return Type Validation
                logResult('return-results', 'üß™ Testing return value validation...', 'info');
                
                // Test add() return values
                const addTrue = attr.add(element, "valid");
                const addFalse = attr.add(null, "invalid");
                logResult('return-results', `add() with valid params: ${addTrue} (${typeof addTrue})`, addTrue === true ? 'success' : 'error');
                logResult('return-results', `add() with null element: ${addFalse} (${typeof addFalse})`, addFalse === false ? 'success' : 'error');
                
                // Test value() return values
                const valueResult = attr.value(element);
                logResult('return-results', `value() result: "${valueResult}" (${typeof valueResult})`, typeof valueResult === 'string' ? 'success' : 'error');
                
                // Test getters
                const attrName = attr.attrName();
                const keyName = attr.keyName();
                const scope = attr.scope();
                logResult('return-results', `attrName(): "${attrName}" (${typeof attrName})`, typeof attrName === 'string' ? 'success' : 'error');
                logResult('return-results', `keyName(): "${keyName}" (${typeof keyName})`, typeof keyName === 'string' ? 'success' : 'error');
                logResult('return-results', `scope(): ${scope} (${typeof scope})`, typeof scope === 'number' ? 'success' : 'error');
                
                // Test 4: Behavior Consistency
                logResult('behavior-results', 'üß™ Testing behavior consistency...', 'info');
                
                const testElement = document.createElement('div');
                
                // Test that all attributors handle the same operations consistently
                const attrs = [
                    new Parchment.Attributor("test1", "data-test1"),
                    new Parchment.StyleAttributor("test2", "color"),
                    new Parchment.ClassAttributor("test3", "text-align")
                ];
                
                attrs.forEach((a, i) => {
                    const addResult = a.add(testElement, "test");
                    const valueResult = a.value(testElement);
                    a.remove(testElement);
                    const valueAfterRemove = a.value(testElement);
                    
                    logResult('behavior-results', `Attributor ${i+1}: add=${addResult}, value="${valueResult}", afterRemove="${valueAfterRemove}"`, 'info');
                });
                
                // Test 5: Edge Case Behavior
                logResult('edge-results', 'üß™ Testing edge case behavior...', 'info');
                
                const edgeAttr = new Parchment.Attributor("edge", "data-edge");
                
                // Test null element
                const nullResult = edgeAttr.add(null, "test");
                logResult('edge-results', `Null element: ${nullResult} (expected: false)`, nullResult === false ? 'success' : 'error');
                
                // Test undefined value
                const undefinedResult = edgeAttr.add(testElement, undefined);
                logResult('edge-results', `Undefined value: ${undefinedResult} (expected: false)`, undefinedResult === false ? 'success' : 'error');
                
                // Test empty string
                const emptyResult = edgeAttr.add(testElement, "");
                logResult('edge-results', `Empty string: ${emptyResult}`, 'info');
                
                // Test special characters
                const specialResult = edgeAttr.add(testElement, "test-with-hyphens_and_underscores");
                logResult('edge-results', `Special characters: ${specialResult}`, 'info');
                
                // Test 6: Cross-Attributor Consistency
                logResult('consistency-results', 'üß™ Testing cross-attributor consistency...', 'info');
                
                const consistencyElement = document.createElement('div');
                const attrs2 = [
                    new Parchment.Attributor("consistency1", "data-consistency1"),
                    new Parchment.StyleAttributor("consistency2", "background-color"),
                    new Parchment.ClassAttributor("consistency3", "font-weight")
                ];
                
                // Test that all attributors can work on the same element without interference
                attrs2.forEach((a, i) => {
                    const result = a.add(consistencyElement, "test");
                    logResult('consistency-results', `Attributor ${i+1} add result: ${result}`, result ? 'success' : 'error');
                });
                
                // Check element state
                logResult('consistency-results', `Element attributes: ${consistencyElement.outerHTML}`, 'info');
                logResult('consistency-results', `Element classes: "${consistencyElement.className}"`, 'info');
                logResult('consistency-results', `Element style: "${consistencyElement.style.cssText}"`, 'info');
                
                // Test that each attributor only affects its own domain
                attrs2.forEach((a, i) => {
                    const value = a.value(consistencyElement);
                    logResult('consistency-results', `Attributor ${i+1} value: "${value}"`, 'info');
                });
                
                logResult('consistency-results', 'üéâ All validation tests completed!', 'success');
                
            } catch (error) {
                logResult('constructor-results', `‚ùå Validation error: ${error.message}`, 'error');
                console.error('Validation error:', error);
            }
        }
        
        runValidationTests();
    </script>
</body>
</html>