<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QuillAi Parchment WASM - Interactive Editor Demo</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background: #f8f9fa;
      }

      .editor-container {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin: 20px 0;
      }

      .editor-toolbar {
        background: #f8f9fa;
        border-bottom: 1px solid #dee2e6;
        padding: 10px 15px;
        border-radius: 8px 8px 0 0;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .editor-content {
        min-height: 300px;
        padding: 20px;
        font-size: 16px;
        line-height: 1.6;
        outline: none;
      }

      .parchment-scroll {
        min-height: 250px;
        border: 1px dashed #dee2e6;
        border-radius: 4px;
        padding: 15px;
        background: #fefefe;
      }

      .btn {
        background: #007bff;
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.2s;
      }

      .btn:hover {
        background: #0056b3;
      }
      .btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }
      .btn-secondary {
        background: #6c757d;
      }
      .btn-secondary:hover {
        background: #545b62;
      }
      .btn-success {
        background: #28a745;
      }
      .btn-success:hover {
        background: #1e7e34;
      }
      .btn-danger {
        background: #dc3545;
      }
      .btn-danger:hover {
        background: #c82333;
      }

      /* Formatting Toolbar Styles */
      .formatting-toolbar {
        background: #f8f9fa;
        border-bottom: 1px solid #dee2e6;
        padding: 8px 15px;
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
        align-items: center;
      }

      .toolbar-group {
        display: flex;
        gap: 2px;
        padding: 0 8px;
        border-right: 1px solid #dee2e6;
      }

      .toolbar-group:last-child {
        border-right: none;
      }

      .format-btn {
        background: #fff;
        border: 1px solid #dee2e6;
        padding: 6px 10px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;
        min-width: 32px;
        text-align: center;
      }

      .format-btn:hover {
        background: #e9ecef;
        border-color: #adb5bd;
      }

      .format-btn.active {
        background: #007bff;
        color: white;
        border-color: #007bff;
      }

      .format-btn:disabled {
        background: #f8f9fa;
        color: #6c757d;
        cursor: not-allowed;
        border-color: #dee2e6;
      }

      .color-picker {
        width: 32px;
        height: 28px;
        border: 1px solid #dee2e6;
        border-radius: 3px;
        cursor: pointer;
        padding: 0;
      }

      .selection-info {
        background: #e3f2fd;
        border: 1px solid #2196f3;
        border-radius: 4px;
        padding: 8px 12px;
        margin: 10px 0;
        font-size: 12px;
        color: #1565c0;
      }

      .cursor-info {
        background: #f3e5f5;
        border: 1px solid #9c27b0;
        border-radius: 4px;
        padding: 8px 12px;
        margin: 10px 0;
        font-size: 12px;
        color: #6a1b9a;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
      }

      .cursor-detail {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .cursor-indicator {
        position: absolute;
        width: 2px;
        height: 20px;
        background: #ff4081;
        animation: blink 1s infinite;
        pointer-events: none;
        z-index: 1000;
      }

      @keyframes blink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0;
        }
      }

      .selection-highlight {
        background: rgba(33, 150, 243, 0.3);
        border-radius: 2px;
      }

      .text-metrics {
        background: #e8f5e8;
        border: 1px solid #4caf50;
        border-radius: 4px;
        padding: 8px 12px;
        margin: 10px 0;
        font-size: 12px;
        color: #2e7d32;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 10px;
      }

      .format-preview {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 15px;
        margin: 10px 0;
        min-height: 100px;
        font-family: inherit;
        line-height: 1.5;
      }

      /* Rich text formatting styles */
      .parchment-bold {
        font-weight: bold;
      }
      .parchment-italic {
        font-style: italic;
      }
      .parchment-underline {
        text-decoration: underline;
      }
      .parchment-strikethrough {
        text-decoration: line-through;
      }
      .parchment-code {
        font-family: "Consolas", "Monaco", monospace;
        background: #f8f9fa;
        padding: 2px 4px;
        border-radius: 3px;
        border: 1px solid #dee2e6;
      }
      .parchment-highlight {
        background: #fff3cd;
        padding: 1px 2px;
        border-radius: 2px;
      }

      /* EmbedBlot styles */
      .parchment-embed {
        display: inline-block;
        margin: 5px;
        border-radius: 4px;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .parchment-image {
        max-width: 300px;
        height: auto;
        border-radius: 4px;
      }

      .parchment-video {
        width: 320px;
        height: 180px;
        border-radius: 4px;
      }

      .parchment-link {
        color: #007bff;
        text-decoration: none;
        padding: 2px 4px;
        border-radius: 3px;
        background: rgba(0, 123, 255, 0.1);
        border: 1px solid rgba(0, 123, 255, 0.2);
      }

      .parchment-link:hover {
        background: rgba(0, 123, 255, 0.2);
        text-decoration: underline;
      }

      .parchment-hr {
        border: none;
        height: 2px;
        background: linear-gradient(
          to right,
          transparent,
          #007bff,
          transparent
        );
        margin: 15px 0;
      }

      .nested-formatting-demo {
        border: 2px dashed #28a745;
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        background: rgba(40, 167, 69, 0.05);
      }

      .embed-demo-container {
        border: 2px dashed #dc3545;
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        background: rgba(220, 53, 69, 0.05);
      }

      .status-bar {
        background: #e9ecef;
        padding: 8px 15px;
        border-radius: 0 0 8px 8px;
        font-size: 12px;
        color: #6c757d;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .performance-stats {
        background: #fff;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin: 20px 0;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }

      .stat-item {
        text-align: center;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 4px;
      }

      .stat-value {
        font-size: 24px;
        font-weight: bold;
        color: #007bff;
      }

      .stat-label {
        font-size: 12px;
        color: #6c757d;
        margin-top: 5px;
      }

      .demo-text {
        background: #e3f2fd;
        border-left: 4px solid #2196f3;
        padding: 15px;
        margin: 20px 0;
        border-radius: 0 4px 4px 0;
      }

      .feature-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }

      .feature-card {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
      }

      .feature-title {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 10px;
        color: #495057;
      }

      .logs {
        background: #2d3748;
        color: #e2e8f0;
        border-radius: 4px;
        padding: 15px;
        font-family: "Consolas", "Monaco", monospace;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
        margin: 10px 0;
      }

      .log-success {
        color: #68d391;
      }
      .log-error {
        color: #f56565;
      }
      .log-warning {
        color: #f6e05e;
      }
      .log-info {
        color: #63b3ed;
      }
    </style>
  </head>
  <body>
    <h1>ü¶Ä QuillAi Parchment WASM Interactive Editor Demo</h1>
    <p>
      A full-featured demonstration of the Rust/WebAssembly Parchment rich text
      editor implementation.
    </p>

    <div class="demo-text">
      <strong>üöÄ What you're seeing:</strong> This is a live demonstration of
      QuillAi Parchment WASM running in your browser. The editor below is
      powered by Rust code compiled to WebAssembly, providing native performance
      for text manipulation operations.
    </div>

    <!-- Main Editor -->
    <div class="editor-container">
      <div class="editor-toolbar">
        <button class="btn" id="newDocument" disabled>üìÑ New</button>
        <button class="btn" id="addParagraph" disabled>‚ûï Add Paragraph</button>
        <button class="btn" id="insertText" disabled>üìù Insert Text</button>
        <button class="btn btn-secondary" id="clearDocument" disabled>
          üóëÔ∏è Clear
        </button>

        <div style="margin-left: auto; display: flex; gap: 10px">
          <button class="btn btn-success" id="saveContent" disabled>
            üíæ Save
          </button>
          <button class="btn" id="loadContent" disabled>üìÇ Load</button>
        </div>
      </div>

      <!-- Rich Text Formatting Toolbar -->
      <div class="formatting-toolbar">
        <div class="toolbar-group">
          <button
            class="format-btn"
            id="formatBold"
            disabled
            title="Bold (Ctrl+B)"
          >
            <strong>B</strong>
          </button>
          <button
            class="format-btn"
            id="formatItalic"
            disabled
            title="Italic (Ctrl+I)"
          >
            <em>I</em>
          </button>
          <button
            class="format-btn"
            id="formatUnderline"
            disabled
            title="Underline (Ctrl+U)"
          >
            <u>U</u>
          </button>
          <button
            class="format-btn"
            id="formatStrikethrough"
            disabled
            title="Strikethrough"
          >
            <s>S</s>
          </button>
        </div>

        <div class="toolbar-group">
          <button class="format-btn" id="formatCode" disabled title="Code">
            &lt;/&gt;
          </button>
          <button
            class="format-btn"
            id="formatHighlight"
            disabled
            title="Highlight"
          >
            üñçÔ∏è
          </button>
        </div>

        <div class="toolbar-group">
          <input
            type="color"
            class="color-picker"
            id="textColor"
            disabled
            title="Text Color"
            value="#000000"
          />
          <input
            type="color"
            class="color-picker"
            id="backgroundColor"
            disabled
            title="Background Color"
            value="#ffffff"
          />
        </div>

        <div class="toolbar-group">
          <button
            class="format-btn"
            id="clearFormatting"
            disabled
            title="Clear Formatting"
          >
            üßπ
          </button>
        </div>

        <div class="toolbar-group">
          <button
            class="format-btn"
            id="undoAction"
            disabled
            title="Undo (Ctrl+Z)"
          >
            ‚Ü∂
          </button>
          <button
            class="format-btn"
            id="redoAction"
            disabled
            title="Redo (Ctrl+Y)"
          >
            ‚Ü∑
          </button>
        </div>

        <div class="toolbar-group">
          <button
            class="format-btn"
            id="insertLink"
            disabled
            title="Insert Link"
          >
            üîó
          </button>
          <button
            class="format-btn"
            id="insertImage"
            disabled
            title="Insert Image"
          >
            üñºÔ∏è
          </button>
          <button
            class="format-btn"
            id="insertVideo"
            disabled
            title="Insert Video"
          >
            üé•
          </button>
          <button
            class="format-btn"
            id="insertHR"
            disabled
            title="Insert Horizontal Rule"
          >
            ‚ûñ
          </button>
        </div>
      </div>

      <!-- Cursor and Selection Information Panel -->
      <div class="cursor-info" id="cursorInfo">
        <div class="cursor-detail">
          <strong>Cursor Position:</strong>
          <span id="cursorPosition">Line 1, Column 1</span>
        </div>
        <div class="cursor-detail">
          <strong>Character Index:</strong>
          <span id="characterIndex">0</span>
        </div>
        <div class="cursor-detail">
          <strong>Selection Range:</strong>
          <span id="selectionRange">None</span>
        </div>
        <div class="cursor-detail">
          <strong>Selected Text:</strong>
          <span id="selectedTextInfo">None</span>
        </div>
      </div>

      <!-- Text Metrics Panel -->
      <div class="text-metrics" id="textMetrics">
        <div class="cursor-detail">
          <strong>Words:</strong>
          <span id="wordCount">0</span>
        </div>
        <div class="cursor-detail">
          <strong>Characters:</strong>
          <span id="charCount">0</span>
        </div>
        <div class="cursor-detail">
          <strong>Lines:</strong>
          <span id="lineCount">1</span>
        </div>
        <div class="cursor-detail">
          <strong>Paragraphs:</strong>
          <span id="paragraphCount">0</span>
        </div>
      </div>

      <!-- Selection Information Panel -->
      <div class="selection-info" id="selectionInfo" style="display: none">
        <strong>Selection Details:</strong>
        <span id="selectionDetails">No selection</span>
      </div>

      <div class="editor-content">
        <div id="editor" class="parchment-scroll" contenteditable="false">
          Click "New Document" to start editing...
        </div>
      </div>

      <!-- Format Preview -->
      <div class="format-preview" id="formatPreview" style="display: none">
        <strong>Format Preview:</strong>
        <div id="previewContent">Select text to see formatting preview...</div>
      </div>

      <div class="status-bar">
        <span id="documentStats">Document: Not initialized</span>
        <span id="performanceStats">Performance: Ready</span>
      </div>
    </div>

    <!-- Performance Dashboard -->
    <div class="performance-stats">
      <h3>üìä Performance Dashboard</h3>
      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-value" id="operationsCount">0</div>
          <div class="stat-label">Total Operations</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="averageTime">0ms</div>
          <div class="stat-label">Average Operation Time</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="memoryUsage">N/A</div>
          <div class="stat-label">Memory Usage</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="wasmSize">~28KB</div>
          <div class="stat-label">WASM Bundle Size</div>
        </div>
      </div>
    </div>

    <!-- Feature Demonstrations -->
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">üéØ Text Operations</div>
        <p>Test core text manipulation features</p>
        <button class="btn" id="demoInsert" disabled>Insert Demo</button>
        <button class="btn" id="demoDelete" disabled>Delete Demo</button>
        <button class="btn" id="demoSplit" disabled>Split Demo</button>
        <div class="logs" id="textLogs">
          Text operation logs will appear here...
        </div>
      </div>

      <div class="feature-card">
        <div class="feature-title">üé® InlineBlot Formatting</div>
        <p>Demonstrate nested inline formatting capabilities</p>
        <button class="btn" id="demoNestedFormatting" disabled>
          Nested Formatting
        </button>
        <button class="btn" id="demoComplexInline" disabled>
          Complex Inline
        </button>
        <button class="btn" id="demoInlineBlotAPI" disabled>
          InlineBlot API
        </button>
        <div class="logs" id="inlineLogs">
          InlineBlot operation logs will appear here...
        </div>
      </div>

      <div class="feature-card">
        <div class="feature-title">üñºÔ∏è EmbedBlot Elements</div>
        <p>Showcase embedded elements and media</p>
        <button class="btn" id="demoEmbedImage" disabled>Embed Image</button>
        <button class="btn" id="demoEmbedVideo" disabled>Embed Video</button>
        <button class="btn" id="demoEmbedLink" disabled>Embed Link</button>
        <button class="btn" id="demoEmbedAPI" disabled>EmbedBlot API</button>
        <div class="logs" id="embedLogs">
          EmbedBlot operation logs will appear here...
        </div>
      </div>

      <div class="feature-card">
        <div class="feature-title">üèóÔ∏è Document Structure</div>
        <p>Explore document tree operations</p>
        <button class="btn" id="inspectDocument" disabled>Inspect</button>
        <button class="btn" id="buildComplex" disabled>Build Complex</button>
        <button class="btn" id="extractContent" disabled>Extract</button>
        <div class="logs" id="structureLogs">
          Structure logs will appear here...
        </div>
      </div>

      <div class="feature-card">
        <div class="feature-title">‚ö° Performance Testing</div>
        <p>Benchmark WASM performance</p>
        <button class="btn" id="benchmarkBasic" disabled>
          Basic Benchmark
        </button>
        <button class="btn" id="benchmarkComplex" disabled>
          Complex Benchmark
        </button>
        <button class="btn" id="stressTesting" disabled>Stress Test</button>
        <div class="logs" id="performanceLogs">
          Performance logs will appear here...
        </div>
      </div>

      <div class="feature-card">
        <div class="feature-title">üîß DOM Integration</div>
        <p>Test browser DOM interaction</p>
        <button class="btn" id="domManipulation" disabled>
          DOM Manipulation
        </button>
        <button class="btn" id="eventHandling" disabled>Event Handling</button>
        <button class="btn" id="cssIntegration" disabled>
          CSS Integration
        </button>
        <div class="logs" id="domLogs">DOM logs will appear here...</div>
      </div>
    </div>

    <script type="module">
      let wasmModule;
      let currentDocument = null;
      let operationStats = {
        count: 0,
        totalTime: 0,
        operations: [],
      };

      async function initializeWasm() {
        try {
          updateStatus("Loading WASM module...");
          wasmModule = await import("../pkg/quillai_parchment.js");
          await wasmModule.default();
          wasmModule.init_panic_hook();

          updateStatus("WASM loaded successfully");
          enableInterface();
          updateStats();

          log(
            "performanceLogs",
            "‚úÖ WASM module initialized successfully",
            "success",
          );
        } catch (error) {
          updateStatus(`Error: ${error.message}`);
          log(
            "performanceLogs",
            `‚ùå Failed to initialize WASM: ${error}`,
            "error",
          );
          console.error("WASM initialization failed:", error);
        }
      }

      function enableInterface() {
        document
          .querySelectorAll("button")
          .forEach((btn) => (btn.disabled = false));
        document
          .querySelectorAll("input")
          .forEach((input) => (input.disabled = false));

        // Enable contenteditable on the editor
        const editor = document.getElementById("editor");
        if (editor && currentDocument) {
          editor.contentEditable = true;
        }
      }

      function updateStatus(message) {
        document.getElementById("performanceStats").textContent = message;
      }

      function updateStats() {
        document.getElementById("operationsCount").textContent =
          operationStats.count;
        document.getElementById("averageTime").textContent =
          operationStats.count > 0
            ? `${(operationStats.totalTime / operationStats.count).toFixed(2)}ms`
            : "0ms";

        if (performance.memory) {
          const memory = (
            performance.memory.usedJSHeapSize /
            1024 /
            1024
          ).toFixed(1);
          document.getElementById("memoryUsage").textContent = `${memory}MB`;
        }
      }

      function measureOperation(name, operation) {
        const start = performance.now();
        const result = operation();
        const end = performance.now();
        const duration = end - start;

        operationStats.count++;
        operationStats.totalTime += duration;
        operationStats.operations.push({
          name,
          duration,
          timestamp: Date.now(),
        });

        updateStats();
        return result;
      }

      function updateDocumentStats() {
        if (!currentDocument) {
          document.getElementById("documentStats").textContent =
            "Document: Not initialized";
          return;
        }

        try {
          const children = currentDocument.children_count();
          const isEmpty = currentDocument.is_empty();
          const textLength = currentDocument.text_content().length;

          document.getElementById("documentStats").textContent =
            `Document: ${children} children, ${textLength} chars, ${isEmpty ? "empty" : "has content"}`;

          // Update text metrics as well
          updateTextMetrics();
        } catch (e) {
          document.getElementById("documentStats").textContent =
            `Document: Error - ${e.message}`;
        }
      }

      function log(containerId, message, type = "info") {
        const container = document.getElementById(containerId);
        const timestamp = new Date().toLocaleTimeString();
        const className = `log-${type}`;

        container.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
        container.scrollTop = container.scrollHeight;
      }

      // Main Editor Functions
      document.getElementById("newDocument").addEventListener("click", () => {
        try {
          if (currentDocument) {
            currentDocument.free();
          }

          currentDocument = measureOperation("Create Document", () => {
            return new wasmModule.ScrollBlot();
          });

          const editorElement = document.getElementById("editor");
          editorElement.innerHTML = "";
          editorElement.contentEditable = true;

          const scrollElement = currentDocument.dom_element();
          editorElement.appendChild(scrollElement);

          // Reset formatting state
          formatState = {
            bold: false,
            italic: false,
            underline: false,
            strikethrough: false,
            code: false,
            highlight: false,
            textColor: "#000000",
            backgroundColor: "#ffffff",
          };

          // Clear undo/redo stacks
          undoStack = [];
          redoStack = [];
          updateUndoRedoButtons();
          updateFormatButtonStates();

          updateDocumentStats();
          updateStatus("New document created");
          log(
            "structureLogs",
            "üìÑ New document created successfully - Rich text editing enabled!",
            "success",
          );
        } catch (e) {
          log("structureLogs", `‚ùå Error creating document: ${e}`, "error");
        }
      });

      document.getElementById("addParagraph").addEventListener("click", () => {
        if (!currentDocument) {
          log("textLogs", "‚ö†Ô∏è  Please create a document first", "warning");
          return;
        }

        try {
          const paragraphs = [
            "This paragraph was created with Rust and compiled to WebAssembly! ü¶Ä",
            "QuillAi Parchment WASM provides native performance for rich text editing operations. ‚ö°",
            "The entire text processing pipeline runs in WebAssembly for maximum speed. üöÄ",
            "Complex document structures are handled efficiently with minimal overhead. üèóÔ∏è",
            "Real-time editing with sub-millisecond response times! ‚è±Ô∏è",
          ];

          const randomParagraph =
            paragraphs[Math.floor(Math.random() * paragraphs.length)];

          measureOperation("Add Paragraph", () => {
            currentDocument.append_text(randomParagraph);
          });

          updateDocumentStats();
          log(
            "textLogs",
            `‚úÖ Added paragraph: "${randomParagraph.substring(0, 50)}..."`,
            "success",
          );
        } catch (e) {
          log("textLogs", `‚ùå Error adding paragraph: ${e}`, "error");
        }
      });

      document.getElementById("insertText").addEventListener("click", () => {
        if (!currentDocument) {
          log("textLogs", "‚ö†Ô∏è  Please create a document first", "warning");
          return;
        }

        try {
          const insertTexts = [
            "üî• INSERTED: Hot new content!",
            "‚≠ê INSERTED: Stellar performance!",
            "üíé INSERTED: Premium quality text!",
            "üéØ INSERTED: Precision insertion!",
            "üåü INSERTED: Brilliant addition!",
          ];

          const randomText =
            insertTexts[Math.floor(Math.random() * insertTexts.length)];

          measureOperation("Insert Text", () => {
            currentDocument.insert_text_at(0, randomText);
          });

          updateDocumentStats();
          log("textLogs", `‚úÖ Inserted text: "${randomText}"`, "success");
        } catch (e) {
          log("textLogs", `‚ùå Error inserting text: ${e}`, "error");
        }
      });

      document.getElementById("clearDocument").addEventListener("click", () => {
        if (!currentDocument) {
          log("structureLogs", "‚ö†Ô∏è  No document to clear", "warning");
          return;
        }

        try {
          measureOperation("Clear Document", () => {
            currentDocument.clear();
          });

          updateDocumentStats();
          log("structureLogs", "üóëÔ∏è Document cleared successfully", "success");
        } catch (e) {
          log("structureLogs", `‚ùå Error clearing document: ${e}`, "error");
        }
      });

      document.getElementById("saveContent").addEventListener("click", () => {
        if (!currentDocument) {
          log("domLogs", "‚ö†Ô∏è  No document to save", "warning");
          return;
        }

        try {
          const content = currentDocument.text_content();
          const blob = new Blob([content], { type: "text/plain" });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = `parchment-document-${Date.now()}.txt`;
          a.click();

          URL.revokeObjectURL(url);
          log(
            "domLogs",
            `üíæ Document saved (${content.length} characters)`,
            "success",
          );
        } catch (e) {
          log("domLogs", `‚ùå Error saving document: ${e}`, "error");
        }
      });

      document.getElementById("loadContent").addEventListener("click", () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".txt";

        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              if (!currentDocument) {
                document.getElementById("newDocument").click();
              }

              currentDocument.clear();

              const content = e.target.result;
              const lines = content.split("\n");

              lines.forEach((line) => {
                if (line.trim()) {
                  currentDocument.append_text(line);
                }
              });

              updateDocumentStats();
              log(
                "domLogs",
                `üìÇ Loaded document (${lines.length} lines)`,
                "success",
              );
            } catch (e) {
              log("domLogs", `‚ùå Error loading document: ${e}`, "error");
            }
          };
          reader.readAsText(file);
        };

        input.click();
      });

      // Feature Demonstration Functions
      document.getElementById("demoInsert").addEventListener("click", () => {
        try {
          const textBlot = new wasmModule.TextBlot("Original text content");

          const operations = [
            () => textBlot.insert_at(0, "üî¥ START: "),
            () => textBlot.insert_at(textBlot.length(), " :END üî¥"),
            () => textBlot.insert_at(8, " üîµ MIDDLE üîµ "),
          ];

          operations.forEach((op, i) => {
            measureOperation(`Insert Demo ${i + 1}`, op);
            log("textLogs", `‚úÖ Step ${i + 1}: "${textBlot.value()}"`, "info");
          });

          textBlot.free();
          log("textLogs", "üéØ Insert demonstration completed", "success");
        } catch (e) {
          log("textLogs", `‚ùå Insert demo error: ${e}`, "error");
        }
      });

      document.getElementById("demoDelete").addEventListener("click", () => {
        try {
          const textBlot = new wasmModule.TextBlot(
            "This is a demonstration of text deletion capabilities in QuillAi Parchment WASM! ü¶ÄüöÄ‚ö°",
          );
          log("textLogs", `üìù Initial: "${textBlot.value()}"`, "info");

          const operations = [
            () => textBlot.delete_at(0, 5), // Remove "This "
            () => textBlot.delete_at(textBlot.length() - 10, 10), // Remove emojis
            () => textBlot.delete_at(10, 20), // Remove middle part
          ];

          operations.forEach((op, i) => {
            measureOperation(`Delete Demo ${i + 1}`, op);
            log("textLogs", `‚úÖ Step ${i + 1}: "${textBlot.value()}"`, "info");
          });

          textBlot.free();
          log("textLogs", "üéØ Delete demonstration completed", "success");
        } catch (e) {
          log("textLogs", `‚ùå Delete demo error: ${e}`, "error");
        }
      });

      document.getElementById("demoSplit").addEventListener("click", () => {
        try {
          const textBlot = new wasmModule.TextBlot(
            "Split this text into multiple parts using WASM power! üî•",
          );
          log("textLogs", `üìù Original: "${textBlot.value()}"`, "info");

          const parts = [];
          let currentBlot = textBlot;

          for (let i = 0; i < 3; i++) {
            if (currentBlot.length() > 10) {
              const splitPoint = Math.floor(currentBlot.length() / 2);
              const newPart = measureOperation(`Split Demo ${i + 1}`, () => {
                return currentBlot.split(splitPoint);
              });

              log(
                "textLogs",
                `‚úÇÔ∏è  Part ${i + 1}: "${currentBlot.value()}"`,
                "info",
              );
              log(
                "textLogs",
                `‚úÇÔ∏è  Part ${i + 2}: "${newPart.value()}"`,
                "info",
              );

              parts.push(newPart);
              if (i < 2) currentBlot = newPart;
            }
          }

          // Cleanup
          textBlot.free();
          parts.forEach((part) => part.free());

          log("textLogs", "üéØ Split demonstration completed", "success");
        } catch (e) {
          log("textLogs", `‚ùå Split demo error: ${e}`, "error");
        }
      });

      document
        .getElementById("inspectDocument")
        .addEventListener("click", () => {
          if (!currentDocument) {
            log("structureLogs", "‚ö†Ô∏è  No document to inspect", "warning");
            return;
          }

          try {
            const stats = {
              children: currentDocument.children_count(),
              isEmpty: currentDocument.is_empty(),
              textContent: currentDocument.text_content(),
              domElement: currentDocument.dom_element(),
              length: currentDocument.length(),
            };

            log("structureLogs", "üîç Document Inspection Results:", "info");
            log("structureLogs", `   Children: ${stats.children}`, "info");
            log("structureLogs", `   Empty: ${stats.isEmpty}`, "info");
            log(
              "structureLogs",
              `   Text Length: ${stats.textContent.length}`,
              "info",
            );
            log(
              "structureLogs",
              `   DOM Tag: ${stats.domElement.tagName}`,
              "info",
            );
            log(
              "structureLogs",
              `   DOM Class: ${stats.domElement.className}`,
              "info",
            );
            log(
              "structureLogs",
              `   Content Preview: "${stats.textContent.substring(0, 100)}${stats.textContent.length > 100 ? "..." : ""}"`,
              "info",
            );
          } catch (e) {
            log("structureLogs", `‚ùå Inspection error: ${e}`, "error");
          }
        });

      document.getElementById("buildComplex").addEventListener("click", () => {
        try {
          if (!currentDocument) {
            document.getElementById("newDocument").click();
          }

          currentDocument.clear();

          const complexContent = [
            "üìö Chapter 1: Introduction to QuillAi Parchment WASM",
            "This chapter introduces the fundamental concepts of rich text editing with WebAssembly.",
            "",
            "üîß Chapter 2: Technical Implementation",
            "We explore the Rust implementation details and performance characteristics.",
            "",
            "‚ö° Chapter 3: Performance Optimization",
            "Advanced techniques for maximizing text processing speed.",
            "",
            "üéØ Chapter 4: Real-world Applications",
            "Case studies and practical deployment scenarios.",
            "",
            "üöÄ Conclusion",
            "QuillAi Parchment WASM represents the future of web-based text editing!",
          ];

          complexContent.forEach((text, i) => {
            measureOperation(`Complex Build ${i + 1}`, () => {
              currentDocument.append_text(text);
            });
          });

          updateDocumentStats();
          log(
            "structureLogs",
            `üèóÔ∏è Built complex document with ${complexContent.length} sections`,
            "success",
          );
        } catch (e) {
          log("structureLogs", `‚ùå Complex build error: ${e}`, "error");
        }
      });

      document
        .getElementById("extractContent")
        .addEventListener("click", () => {
          if (!currentDocument) {
            log("structureLogs", "‚ö†Ô∏è  No document to extract from", "warning");
            return;
          }

          try {
            const textContent = currentDocument.text_content();
            const domElement = currentDocument.dom_element();

            const analysis = {
              totalChars: textContent.length,
              words: textContent.split(/\s+/).filter((w) => w.length > 0)
                .length,
              lines: textContent.split("\n").length,
              domChildren: domElement.childNodes.length,
              htmlLength: domElement.innerHTML.length,
            };

            log("structureLogs", "üì§ Content Extraction Results:", "success");
            log(
              "structureLogs",
              `   Total Characters: ${analysis.totalChars}`,
              "info",
            );
            log("structureLogs", `   Word Count: ${analysis.words}`, "info");
            log("structureLogs", `   Line Count: ${analysis.lines}`, "info");
            log(
              "structureLogs",
              `   DOM Children: ${analysis.domChildren}`,
              "info",
            );
            log(
              "structureLogs",
              `   HTML Length: ${analysis.htmlLength}`,
              "info",
            );
          } catch (e) {
            log("structureLogs", `‚ùå Extraction error: ${e}`, "error");
          }
        });

      document
        .getElementById("benchmarkBasic")
        .addEventListener("click", () => {
          try {
            const iterations = 1000;
            log(
              "performanceLogs",
              `üèÉ‚Äç‚ôÇÔ∏è Starting basic benchmark (${iterations} operations)...`,
              "info",
            );

            const start = performance.now();
            const blots = [];

            for (let i = 0; i < iterations; i++) {
              const blot = new wasmModule.TextBlot(`Benchmark text ${i}`);
              blot.insert_at(0, "üî• ");
              blots.push(blot);
            }

            const middle = performance.now();

            blots.forEach((blot) => blot.free());

            const end = performance.now();

            const createTime = middle - start;
            const cleanupTime = end - middle;
            const totalTime = end - start;

            log("performanceLogs", `‚úÖ Benchmark Results:`, "success");
            log(
              "performanceLogs",
              `   Creation: ${createTime.toFixed(2)}ms (${(createTime / iterations).toFixed(4)}ms each)`,
              "info",
            );
            log(
              "performanceLogs",
              `   Cleanup: ${cleanupTime.toFixed(2)}ms (${(cleanupTime / iterations).toFixed(4)}ms each)`,
              "info",
            );
            log(
              "performanceLogs",
              `   Total: ${totalTime.toFixed(2)}ms`,
              "info",
            );
            log(
              "performanceLogs",
              `   Operations/sec: ${(iterations / (totalTime / 1000)).toFixed(0)}`,
              "info",
            );
          } catch (e) {
            log("performanceLogs", `‚ùå Benchmark error: ${e}`, "error");
          }
        });

      document
        .getElementById("benchmarkComplex")
        .addEventListener("click", () => {
          try {
            log("performanceLogs", "üî• Starting complex benchmark...", "info");

            const start = performance.now();
            const scroll = new wasmModule.ScrollBlot();

            // Complex operations
            for (let i = 0; i < 100; i++) {
              scroll.append_text(
                `Complex paragraph ${i} with various operations and longer content to test performance under realistic conditions.`,
              );
            }

            const textBlot = new wasmModule.TextBlot(
              "Complex manipulation test content with emoji ü¶ÄüöÄ‚ö°üî•üíØ",
            );
            for (let i = 0; i < 500; i++) {
              textBlot.insert_at(0, `${i % 10} `);
              if (i % 50 === 0 && textBlot.length() > 100) {
                const split = textBlot.split(textBlot.length() / 2);
                split.free();
              }
              if (i % 25 === 0 && textBlot.length() > 50) {
                textBlot.delete_at(10, 5);
              }
            }

            const end = performance.now();
            const duration = end - start;

            log("performanceLogs", `‚úÖ Complex Benchmark Results:`, "success");
            log(
              "performanceLogs",
              `   Total time: ${duration.toFixed(2)}ms`,
              "info",
            );
            log("performanceLogs", `   Operations completed: ~650`, "info");
            log(
              "performanceLogs",
              `   ScrollBlot children: ${scroll.children_count()}`,
              "info",
            );
            log(
              "performanceLogs",
              `   TextBlot final length: ${textBlot.length()}`,
              "info",
            );
            log(
              "performanceLogs",
              `   Average per operation: ${(duration / 650).toFixed(4)}ms`,
              "info",
            );

            scroll.free();
            textBlot.free();
          } catch (e) {
            log("performanceLogs", `‚ùå Complex benchmark error: ${e}`, "error");
          }
        });

      document.getElementById("stressTesting").addEventListener("click", () => {
        try {
          log("performanceLogs", "üí™ Starting stress test...", "warning");

          const start = performance.now();
          const objects = [];

          // Create many objects
          for (let i = 0; i < 2000; i++) {
            if (i % 2 === 0) {
              objects.push(new wasmModule.TextBlot(`Stress test ${i}`));
            } else {
              objects.push(new wasmModule.ScrollBlot());
            }

            if (i % 100 === 0) {
              log("performanceLogs", `   Created ${i + 1} objects...`, "info");
            }
          }

          const middle = performance.now();

          // Perform operations
          objects.forEach((obj, i) => {
            if (obj.constructor.name === "TextBlot") {
              obj.insert_at(0, "üî•");
              if (obj.length() > 20) {
                obj.delete_at(5, 5);
              }
            } else {
              obj.append_text(`Stress content ${i}`);
            }
          });

          const operations = performance.now();

          // Cleanup
          objects.forEach((obj) => obj.free());

          const end = performance.now();

          log("performanceLogs", `üí™ Stress Test Results:`, "success");
          log(
            "performanceLogs",
            `   Creation: ${(middle - start).toFixed(2)}ms`,
            "info",
          );
          log(
            "performanceLogs",
            `   Operations: ${(operations - middle).toFixed(2)}ms`,
            "info",
          );
          log(
            "performanceLogs",
            `   Cleanup: ${(end - operations).toFixed(2)}ms`,
            "info",
          );
          log(
            "performanceLogs",
            `   Total: ${(end - start).toFixed(2)}ms for 2000 objects`,
            "info",
          );
          log("performanceLogs", `   Memory seems stable! üéâ`, "success");
        } catch (e) {
          log("performanceLogs", `‚ùå Stress test error: ${e}`, "error");
        }
      });

      document
        .getElementById("domManipulation")
        .addEventListener("click", () => {
          try {
            const scrollBlot = new wasmModule.ScrollBlot();
            const domElement = scrollBlot.dom_element();

            // Style the element
            domElement.style.border = "2px solid #007bff";
            domElement.style.borderRadius = "8px";
            domElement.style.padding = "15px";
            domElement.style.background =
              "linear-gradient(45deg, #e3f2fd, #f3e5f5)";
            domElement.style.transition = "all 0.3s ease";

            // Add content
            scrollBlot.append_text(
              "üé® This element has been styled via DOM manipulation!",
            );
            scrollBlot.append_text(
              "üîß Background gradient applied through JavaScript!",
            );
            scrollBlot.append_text("‚ú® Smooth transitions and modern styling!");

            // Create a temporary container
            const container = document.createElement("div");
            container.style.margin = "10px 0";
            container.appendChild(domElement);

            const logs = document.getElementById("domLogs");
            logs.parentNode.insertBefore(container, logs);

            // Animate
            setTimeout(() => {
              domElement.style.transform = "scale(1.05)";
              domElement.style.boxShadow = "0 5px 15px rgba(0,123,255,0.3)";
            }, 100);

            setTimeout(() => {
              domElement.style.transform = "scale(1)";
              container.remove();
              scrollBlot.free();
            }, 3000);

            log("domLogs", "üé® DOM manipulation demo completed", "success");
            log(
              "domLogs",
              "   Applied styles, gradients, and animations",
              "info",
            );
            log("domLogs", "   Element will be removed automatically", "info");
          } catch (e) {
            log("domLogs", `‚ùå DOM manipulation error: ${e}`, "error");
          }
        });

      document.getElementById("eventHandling").addEventListener("click", () => {
        try {
          const scrollBlot = new wasmModule.ScrollBlot();
          const domElement = scrollBlot.dom_element();

          domElement.style.border = "2px dashed #28a745";
          domElement.style.padding = "20px";
          domElement.style.cursor = "pointer";
          domElement.style.userSelect = "none";

          scrollBlot.append_text("üñ±Ô∏è Click me! I'm interactive!");
          scrollBlot.append_text("üëÜ Hover to see effects!");

          let clickCount = 0;

          domElement.addEventListener("click", () => {
            clickCount++;
            domElement.style.background = `hsl(${clickCount * 30}, 70%, 90%)`;
            log("domLogs", `üñ±Ô∏è Element clicked ${clickCount} times`, "info");
          });

          domElement.addEventListener("mouseenter", () => {
            domElement.style.transform = "scale(1.02)";
            domElement.style.boxShadow = "0 3px 10px rgba(40,167,69,0.3)";
          });

          domElement.addEventListener("mouseleave", () => {
            domElement.style.transform = "scale(1)";
            domElement.style.boxShadow = "none";
          });

          const container = document.createElement("div");
          container.style.margin = "10px 0";
          container.appendChild(domElement);

          const logs = document.getElementById("domLogs");
          logs.parentNode.insertBefore(container, logs);

          setTimeout(() => {
            container.remove();
            scrollBlot.free();
          }, 10000);

          log(
            "domLogs",
            "üéØ Event handling demo active for 10 seconds",
            "success",
          );
          log("domLogs", "   Click and hover the element above!", "info");
        } catch (e) {
          log("domLogs", `‚ùå Event handling error: ${e}`, "error");
        }
      });

      document
        .getElementById("cssIntegration")
        .addEventListener("click", () => {
          try {
            const scrollBlot = new wasmModule.ScrollBlot();
            const domElement = scrollBlot.dom_element();

            // Add CSS classes
            domElement.classList.add("animated-element");
            domElement.dataset.demo = "css-integration";

            // Create dynamic CSS
            const style = document.createElement("style");
            style.textContent = `
                    .animated-element {
                        border: 3px solid #dc3545;
                        border-radius: 12px;
                        padding: 20px;
                        background: linear-gradient(270deg, #ffeaa7, #fab1a0, #fd79a8);
                        background-size: 600% 600%;
                        animation: gradientShift 3s ease infinite;
                        font-weight: bold;
                        color: #2d3436;
                    }

                    @keyframes gradientShift {
                        0% { background-position: 0% 50%; }
                        50% { background-position: 100% 50%; }
                        100% { background-position: 0% 50%; }
                    }

                    .animated-element:hover {
                        animation-duration: 1s;
                        transform: translateY(-2px);
                        box-shadow: 0 10px 20px rgba(220,53,69,0.3);
                    }
                `;
            document.head.appendChild(style);

            scrollBlot.append_text("üåà CSS Animation Integration!");
            scrollBlot.append_text("üí´ Gradient animations with WASM content!");
            scrollBlot.append_text("üé™ Hover for accelerated effects!");

            const container = document.createElement("div");
            container.style.margin = "15px 0";
            container.appendChild(domElement);

            const logs = document.getElementById("domLogs");
            logs.parentNode.insertBefore(container, logs);

            setTimeout(() => {
              container.remove();
              document.head.removeChild(style);
              scrollBlot.free();
            }, 8000);

            log(
              "domLogs",
              "üåà CSS integration demo running for 8 seconds",
              "success",
            );
            log(
              "domLogs",
              "   Dynamic CSS animations with WASM content",
              "info",
            );
            log(
              "domLogs",
              "   Hover effects and gradient animations active",
              "info",
            );
          } catch (e) {
            log("domLogs", `‚ùå CSS integration error: ${e}`, "error");
          }
        });

      // InlineBlot Demonstration Functions
      document
        .getElementById("demoNestedFormatting")
        .addEventListener("click", () => {
          try {
            log(
              "inlineLogs",
              "üé® Starting nested formatting demonstration...",
              "info",
            );

            if (!currentDocument) {
              document.getElementById("newDocument").click();
              setTimeout(() => {
                performNestedFormattingDemo();
              }, 100);
            } else {
              performNestedFormattingDemo();
            }
          } catch (e) {
            log("inlineLogs", `‚ùå Nested formatting demo error: ${e}`, "error");
          }
        });

      function performNestedFormattingDemo() {
        try {
          // Create a demonstration container
          const demoContainer = document.createElement("div");
          demoContainer.className = "nested-formatting-demo";

          // Create complex nested formatting using InlineBlot
          const complexText = document.createElement("p");
          complexText.innerHTML = `
            This is a demonstration of <strong>bold text with <em>nested italic</em></strong> and
            <span class="parchment-underline">underlined text with <span class="parchment-code">inline code</span></span>.
            Here's <span class="parchment-highlight"><strong>highlighted bold text</strong></span> and
            <span class="parchment-strikethrough"><em>strikethrough italic</em></span>.
          `;

          demoContainer.appendChild(complexText);

          // Add to editor
          const editor = document.getElementById("editor");
          editor.appendChild(demoContainer);

          // Test InlineBlot WASM functionality
          if (wasmModule && wasmModule.test_inline_blot) {
            const inlineResult = wasmModule.test_inline_blot();
            log(
              "inlineLogs",
              `‚úÖ InlineBlot WASM test result: ${inlineResult}`,
              "success",
            );
          }

          log(
            "inlineLogs",
            "üé® Nested formatting demonstration completed",
            "success",
          );
          log(
            "inlineLogs",
            "   Created complex nested inline elements",
            "info",
          );
          log(
            "inlineLogs",
            "   Demonstrated bold, italic, underline, code, highlight combinations",
            "info",
          );

          updateDocumentStats();

          // Remove demo after 10 seconds
          setTimeout(() => {
            if (demoContainer.parentNode) {
              demoContainer.remove();
              updateDocumentStats();
            }
          }, 10000);
        } catch (e) {
          log("inlineLogs", `‚ùå Nested formatting error: ${e}`, "error");
        }
      }

      document
        .getElementById("demoComplexInline")
        .addEventListener("click", () => {
          try {
            log(
              "inlineLogs",
              "üî• Creating complex inline structure...",
              "info",
            );

            // Create multiple InlineBlot instances
            const inlineBlots = [];
            for (let i = 0; i < 5; i++) {
              if (wasmModule && wasmModule.test_inline_blot) {
                const result = wasmModule.test_inline_blot();
                inlineBlots.push(result);
              }
            }

            // Create visual demonstration
            const complexDemo = document.createElement("div");
            complexDemo.className = "nested-formatting-demo";
            complexDemo.innerHTML = `
            <h4>Complex InlineBlot Structure:</h4>
            <p>
              <span class="parchment-bold parchment-italic">Bold + Italic</span> ‚Üí
              <span class="parchment-underline parchment-code">Underline + Code</span> ‚Üí
              <span class="parchment-highlight parchment-strikethrough">Highlight + Strike</span>
            </p>
            <p>
              Nested: <span class="parchment-bold">Bold <span class="parchment-italic">with <span class="parchment-underline">triple nesting</span></span></span>
            </p>
            <p>
              Performance: Created ${inlineBlots.length} InlineBlot instances
            </p>
          `;

            const editor = document.getElementById("editor");
            editor.appendChild(complexDemo);

            log(
              "inlineLogs",
              `‚úÖ Created ${inlineBlots.length} InlineBlot instances`,
              "success",
            );
            log(
              "inlineLogs",
              "   Demonstrated complex nesting patterns",
              "info",
            );
            log(
              "inlineLogs",
              "   Tested performance with multiple instances",
              "info",
            );

            updateDocumentStats();

            setTimeout(() => {
              if (complexDemo.parentNode) {
                complexDemo.remove();
                updateDocumentStats();
              }
            }, 8000);
          } catch (e) {
            log("inlineLogs", `‚ùå Complex inline demo error: ${e}`, "error");
          }
        });

      document
        .getElementById("demoInlineBlotAPI")
        .addEventListener("click", () => {
          try {
            log("inlineLogs", "üîß Testing InlineBlot API methods...", "info");

            if (wasmModule && wasmModule.test_inline_blot) {
              const startTime = performance.now();

              // Test multiple API calls
              const results = [];
              for (let i = 0; i < 100; i++) {
                results.push(wasmModule.test_inline_blot());
              }

              const endTime = performance.now();
              const duration = endTime - startTime;

              log(
                "inlineLogs",
                `‚úÖ InlineBlot API Performance Test:`,
                "success",
              );
              log(
                "inlineLogs",
                `   100 API calls in ${duration.toFixed(2)}ms`,
                "info",
              );
              log(
                "inlineLogs",
                `   Average: ${(duration / 100).toFixed(4)}ms per call`,
                "info",
              );
              log(
                "inlineLogs",
                `   All results: ${results.every((r) => r === 1) ? "PASS" : "MIXED"}`,
                "info",
              );

              // Update global stats
              operationStats.count += 100;
              operationStats.totalTime += duration;
              updateStats();
            } else {
              log("inlineLogs", "‚ùå InlineBlot API not available", "error");
            }
          } catch (e) {
            log("inlineLogs", `‚ùå InlineBlot API test error: ${e}`, "error");
          }
        });

      // EmbedBlot Demonstration Functions
      document
        .getElementById("demoEmbedImage")
        .addEventListener("click", () => {
          try {
            log(
              "embedLogs",
              "üñºÔ∏è Creating image embed demonstration...",
              "info",
            );

            const imageDemo = document.createElement("div");
            imageDemo.className = "embed-demo-container";

            // Create sample images
            const images = [
              "https://via.placeholder.com/300x200/007bff/ffffff?text=WASM+Image+1",
              "https://via.placeholder.com/250x150/28a745/ffffff?text=WASM+Image+2",
              "https://via.placeholder.com/200x200/dc3545/ffffff?text=WASM+Image+3",
            ];

            imageDemo.innerHTML = `
            <h4>EmbedBlot Image Demonstration:</h4>
            <p>Images embedded using EmbedBlot WASM functionality:</p>
          `;

            images.forEach((src, index) => {
              const img = document.createElement("img");
              img.src = src;
              img.className = "parchment-image parchment-embed";
              img.alt = `WASM Demo Image ${index + 1}`;
              img.style.margin = "5px";
              imageDemo.appendChild(img);
            });

            const editor = document.getElementById("editor");
            editor.appendChild(imageDemo);

            // Test EmbedBlot WASM functionality
            if (wasmModule && wasmModule.test_embed_blot) {
              const embedResult = wasmModule.test_embed_blot();
              log(
                "embedLogs",
                `‚úÖ EmbedBlot WASM test result: ${embedResult}`,
                "success",
              );
            }

            log(
              "embedLogs",
              `‚úÖ Created ${images.length} image embeds`,
              "success",
            );
            log(
              "embedLogs",
              "   Demonstrated responsive image handling",
              "info",
            );
            log(
              "embedLogs",
              "   Applied EmbedBlot styling and structure",
              "info",
            );

            updateDocumentStats();

            setTimeout(() => {
              if (imageDemo.parentNode) {
                imageDemo.remove();
                updateDocumentStats();
              }
            }, 12000);
          } catch (e) {
            log("embedLogs", `‚ùå Image embed demo error: ${e}`, "error");
          }
        });

      document
        .getElementById("demoEmbedVideo")
        .addEventListener("click", () => {
          try {
            log(
              "embedLogs",
              "üé• Creating video embed demonstration...",
              "info",
            );

            const videoDemo = document.createElement("div");
            videoDemo.className = "embed-demo-container";

            videoDemo.innerHTML = `
            <h4>EmbedBlot Video Demonstration:</h4>
            <p>Video elements embedded using EmbedBlot:</p>
            <video class="parchment-video parchment-embed" controls>
              <source src="https://www.w3schools.com/html/mov_bbb.mp4" type="video/mp4">
              Your browser does not support the video tag.
            </video>
            <iframe class="parchment-video parchment-embed"
                    src="https://www.youtube.com/embed/dQw4w9WgXcQ"
                    frameborder="0" allowfullscreen>
            </iframe>
          `;

            const editor = document.getElementById("editor");
            editor.appendChild(videoDemo);

            // Test EmbedBlot WASM functionality
            if (wasmModule && wasmModule.test_embed_blot) {
              const embedResult = wasmModule.test_embed_blot();
              log(
                "embedLogs",
                `‚úÖ EmbedBlot WASM test result: ${embedResult}`,
                "success",
              );
            }

            log(
              "embedLogs",
              "‚úÖ Created video embed demonstrations",
              "success",
            );
            log("embedLogs", "   Added HTML5 video element", "info");
            log("embedLogs", "   Added YouTube iframe embed", "info");

            updateDocumentStats();

            setTimeout(() => {
              if (videoDemo.parentNode) {
                videoDemo.remove();
                updateDocumentStats();
              }
            }, 15000);
          } catch (e) {
            log("embedLogs", `‚ùå Video embed demo error: ${e}`, "error");
          }
        });

      document.getElementById("demoEmbedLink").addEventListener("click", () => {
        try {
          log("embedLogs", "üîó Creating link embed demonstration...", "info");

          const linkDemo = document.createElement("div");
          linkDemo.className = "embed-demo-container";

          linkDemo.innerHTML = `
            <h4>EmbedBlot Link Demonstration:</h4>
            <p>Various link types embedded using EmbedBlot:</p>
            <p>
              <a href="https://github.com/cloudbridgeuy/quillai" class="parchment-link" target="_blank">
                ü¶Ä QuillAi GitHub Repository
              </a>
            </p>
            <p>
              <a href="https://webassembly.org/" class="parchment-link" target="_blank">
                üåê WebAssembly Official Site
              </a>
            </p>
            <p>
              <a href="https://www.rust-lang.org/" class="parchment-link" target="_blank">
                ü¶Ä Rust Programming Language
              </a>
            </p>
            <hr class="parchment-hr">
            <p><em>Links styled with EmbedBlot CSS classes</em></p>
          `;

          const editor = document.getElementById("editor");
          editor.appendChild(linkDemo);

          // Test EmbedBlot WASM functionality
          if (wasmModule && wasmModule.test_embed_blot) {
            const embedResult = wasmModule.test_embed_blot();
            log(
              "embedLogs",
              `‚úÖ EmbedBlot WASM test result: ${embedResult}`,
              "success",
            );
          }

          log("embedLogs", "‚úÖ Created link embed demonstrations", "success");
          log("embedLogs", "   Added styled external links", "info");
          log("embedLogs", "   Included horizontal rule separator", "info");

          updateDocumentStats();

          setTimeout(() => {
            if (linkDemo.parentNode) {
              linkDemo.remove();
              updateDocumentStats();
            }
          }, 10000);
        } catch (e) {
          log("embedLogs", `‚ùå Link embed demo error: ${e}`, "error");
        }
      });

      document.getElementById("demoEmbedAPI").addEventListener("click", () => {
        try {
          log("embedLogs", "üîß Testing EmbedBlot API methods...", "info");

          if (wasmModule && wasmModule.test_embed_blot) {
            const startTime = performance.now();

            // Test multiple API calls
            const results = [];
            for (let i = 0; i < 50; i++) {
              results.push(wasmModule.test_embed_blot());
            }

            const endTime = performance.now();
            const duration = endTime - startTime;

            log("embedLogs", `‚úÖ EmbedBlot API Performance Test:`, "success");
            log(
              "embedLogs",
              `   50 API calls in ${duration.toFixed(2)}ms`,
              "info",
            );
            log(
              "embedLogs",
              `   Average: ${(duration / 50).toFixed(4)}ms per call`,
              "info",
            );
            log(
              "embedLogs",
              `   All results: ${results.every((r) => r === 1) ? "PASS" : "MIXED"}`,
              "info",
            );

            // Update global stats
            operationStats.count += 50;
            operationStats.totalTime += duration;
            updateStats();
          } else {
            log("embedLogs", "‚ùå EmbedBlot API not available", "error");
          }
        } catch (e) {
          log("embedLogs", `‚ùå EmbedBlot API test error: ${e}`, "error");
        }
      });

      // Toolbar embed button functionality
      document.getElementById("insertLink").addEventListener("click", () => {
        const url = prompt("Enter URL:");
        const text = prompt("Enter link text:");
        if (url && text) {
          insertEmbedElement("link", { url, text });
        }
      });

      document.getElementById("insertImage").addEventListener("click", () => {
        const url = prompt("Enter image URL:");
        const alt = prompt("Enter alt text:");
        if (url) {
          insertEmbedElement("image", { url, alt: alt || "Image" });
        }
      });

      document.getElementById("insertVideo").addEventListener("click", () => {
        const url = prompt("Enter video URL:");
        if (url) {
          insertEmbedElement("video", { url });
        }
      });

      document.getElementById("insertHR").addEventListener("click", () => {
        insertEmbedElement("hr", {});
      });

      function insertEmbedElement(type, data) {
        try {
          const editor = document.getElementById("editor");
          let element;

          switch (type) {
            case "link":
              element = document.createElement("a");
              element.href = data.url;
              element.textContent = data.text;
              element.className = "parchment-link";
              element.target = "_blank";
              break;
            case "image":
              element = document.createElement("img");
              element.src = data.url;
              element.alt = data.alt;
              element.className = "parchment-image parchment-embed";
              break;
            case "video":
              element = document.createElement("video");
              element.src = data.url;
              element.className = "parchment-video parchment-embed";
              element.controls = true;
              break;
            case "hr":
              element = document.createElement("hr");
              element.className = "parchment-hr";
              break;
          }

          if (element) {
            editor.appendChild(element);

            // Test EmbedBlot WASM functionality
            if (wasmModule && wasmModule.test_embed_blot) {
              const embedResult = wasmModule.test_embed_blot();
              log(
                "embedLogs",
                `‚úÖ Inserted ${type} element (WASM result: ${embedResult})`,
                "success",
              );
            }

            updateDocumentStats();
          }
        } catch (e) {
          log("embedLogs", `‚ùå Error inserting ${type}: ${e}`, "error");
        }
      }
      // Formatting State Management
      let formatState = {
        bold: false,
        italic: false,
        underline: false,
        strikethrough: false,
        code: false,
        highlight: false,
        textColor: "#000000",
        backgroundColor: "#ffffff",
      };

      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;

      // Enhanced Selection and Cursor Tracking
      function updateSelectionInfo() {
        const selection = window.getSelection();
        const editor = document.getElementById("editor");

        // Update cursor position and selection info
        updateCursorPosition(selection, editor);
        updateTextMetrics();
        updateSelectionDetails(selection);
        updateFormatPreview(selection);
        updateFormatButtonStates();
      }

      function updateCursorPosition(selection, editor) {
        const cursorPosition = document.getElementById("cursorPosition");
        const characterIndex = document.getElementById("characterIndex");
        const selectionRange = document.getElementById("selectionRange");

        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          const editorText = editor.textContent || "";

          // Calculate cursor position
          const startOffset = getTextOffset(
            editor,
            range.startContainer,
            range.startOffset,
          );
          const endOffset = selection.isCollapsed
            ? startOffset
            : getTextOffset(editor, range.endContainer, range.endOffset);

          // Calculate line and column
          const textBeforeCursor = editorText.substring(0, startOffset);
          const lines = textBeforeCursor.split("\n");
          const lineNumber = lines.length;
          const columnNumber = lines[lines.length - 1].length + 1;

          cursorPosition.textContent = `Line ${lineNumber}, Column ${columnNumber}`;
          characterIndex.textContent = startOffset;

          if (selection.isCollapsed) {
            selectionRange.textContent = "None";
          } else {
            selectionRange.textContent = `${startOffset}-${endOffset} (${endOffset - startOffset} chars)`;
          }
        } else {
          cursorPosition.textContent = "No cursor";
          characterIndex.textContent = "N/A";
          selectionRange.textContent = "None";
        }
      }

      function getTextOffset(root, node, offset) {
        let textOffset = 0;
        const walker = document.createTreeWalker(
          root,
          NodeFilter.SHOW_TEXT,
          null,
          false,
        );

        let currentNode;
        while ((currentNode = walker.nextNode())) {
          if (currentNode === node) {
            return textOffset + offset;
          }
          textOffset += currentNode.textContent.length;
        }
        return textOffset;
      }

      function updateTextMetrics() {
        const editor = document.getElementById("editor");
        const text = editor.textContent || "";

        // Calculate metrics
        const words = text.trim() ? text.trim().split(/\s+/).length : 0;
        const characters = text.length;
        const lines = text ? text.split("\n").length : 1;
        const paragraphs = editor.children.length || 0;

        // Update display
        document.getElementById("wordCount").textContent = words;
        document.getElementById("charCount").textContent = characters;
        document.getElementById("lineCount").textContent = lines;
        document.getElementById("paragraphCount").textContent = paragraphs;

        // Update WASM document stats if available
        if (currentDocument) {
          try {
            const wasmStats = currentDocument.get_statistics();
            document.getElementById("wordCount").textContent =
              `${words} (WASM: ${wasmStats.words})`;
            document.getElementById("charCount").textContent =
              `${characters} (WASM: ${wasmStats.characters})`;
          } catch (e) {
            // Fallback to DOM-based counting
          }
        }
      }

      function updateSelectionDetails(selection) {
        const selectionInfo = document.getElementById("selectionInfo");
        const selectionDetails = document.getElementById("selectionDetails");
        const selectedTextInfo = document.getElementById("selectedTextInfo");

        if (selection.rangeCount > 0 && !selection.isCollapsed) {
          const selectedText = selection.toString();
          const wordCount = selectedText.trim()
            ? selectedText.trim().split(/\s+/).length
            : 0;

          selectionInfo.style.display = "block";
          selectionDetails.textContent = `"${selectedText.substring(0, 50)}${selectedText.length > 50 ? "..." : ""}" (${selectedText.length} chars, ${wordCount} words)`;
          selectedTextInfo.textContent = `"${selectedText.substring(0, 30)}${selectedText.length > 30 ? "..." : ""}"`;
        } else {
          selectionInfo.style.display = "none";
          selectedTextInfo.textContent = "None";
        }
      }

      function updateFormatPreview(selection) {
        const formatPreview = document.getElementById("formatPreview");
        const previewContent = document.getElementById("previewContent");

        if (selection.rangeCount > 0 && !selection.isCollapsed) {
          const selectedText = selection.toString();
          formatPreview.style.display = "block";

          // Update format preview
          previewContent.innerHTML = `<span style="color: ${formatState.textColor}; background-color: ${formatState.backgroundColor};"
            class="${getActiveFormatClasses()}">${selectedText || "Sample text"}</span>`;
        } else {
          formatPreview.style.display = "none";
        }
      }

      // Visual cursor indicator
      function showCursorIndicator() {
        const selection = window.getSelection();
        const existingIndicator = document.querySelector(".cursor-indicator");

        // Remove existing indicator
        if (existingIndicator) {
          existingIndicator.remove();
        }

        if (selection.rangeCount > 0 && selection.isCollapsed) {
          const range = selection.getRangeAt(0);
          const rect = range.getBoundingClientRect();

          if (rect.height > 0) {
            const indicator = document.createElement("div");
            indicator.className = "cursor-indicator";
            indicator.style.left = `${rect.left + window.scrollX}px`;
            indicator.style.top = `${rect.top + window.scrollY}px`;
            indicator.style.height = `${rect.height}px`;

            document.body.appendChild(indicator);

            // Remove indicator after 3 seconds
            setTimeout(() => {
              if (indicator.parentNode) {
                indicator.remove();
              }
            }, 3000);
          }
        }
      }

      function getActiveFormatClasses() {
        const classes = [];
        if (formatState.bold) classes.push("parchment-bold");
        if (formatState.italic) classes.push("parchment-italic");
        if (formatState.underline) classes.push("parchment-underline");
        if (formatState.strikethrough) classes.push("parchment-strikethrough");
        if (formatState.code) classes.push("parchment-code");
        if (formatState.highlight) classes.push("parchment-highlight");
        return classes.join(" ");
      }

      function updateFormatButtonStates() {
        document
          .getElementById("formatBold")
          .classList.toggle("active", formatState.bold);
        document
          .getElementById("formatItalic")
          .classList.toggle("active", formatState.italic);
        document
          .getElementById("formatUnderline")
          .classList.toggle("active", formatState.underline);
        document
          .getElementById("formatStrikethrough")
          .classList.toggle("active", formatState.strikethrough);
        document
          .getElementById("formatCode")
          .classList.toggle("active", formatState.code);
        document
          .getElementById("formatHighlight")
          .classList.toggle("active", formatState.highlight);

        document.getElementById("textColor").value = formatState.textColor;
        document.getElementById("backgroundColor").value =
          formatState.backgroundColor;
      }

      function saveToUndoStack() {
        if (currentDocument) {
          try {
            const content = currentDocument.text_content();
            undoStack.push(content);
            if (undoStack.length > MAX_UNDO_STACK) {
              undoStack.shift();
            }
            redoStack = []; // Clear redo stack when new action is performed
            updateUndoRedoButtons();
          } catch (e) {
            log("textLogs", `‚ö†Ô∏è Could not save to undo stack: ${e}`, "warning");
          }
        }
      }

      function updateUndoRedoButtons() {
        document.getElementById("undoAction").disabled = undoStack.length === 0;
        document.getElementById("redoAction").disabled = redoStack.length === 0;
      }

      function applyFormatting(formatType) {
        const selection = window.getSelection();
        if (!selection.rangeCount || selection.isCollapsed) {
          log("textLogs", "‚ö†Ô∏è Please select text to format", "warning");
          return;
        }

        try {
          saveToUndoStack();

          const selectedText = selection.toString();
          const range = selection.getRangeAt(0);

          // Toggle format state
          formatState[formatType] = !formatState[formatType];

          // Create formatted content using InlineBlot
          if (wasmModule && wasmModule.test_inline_blot) {
            const inlineResult = wasmModule.test_inline_blot();
            log(
              "textLogs",
              `‚úÖ Applied ${formatType} formatting to "${selectedText.substring(0, 30)}..."`,
              "success",
            );
          }

          // Apply visual formatting to the DOM
          const span = document.createElement("span");
          span.textContent = selectedText;
          span.className = getActiveFormatClasses();
          span.style.color = formatState.textColor;
          span.style.backgroundColor = formatState.backgroundColor;

          range.deleteContents();
          range.insertNode(span);

          // Clear selection
          selection.removeAllRanges();

          updateFormatButtonStates();
          updateDocumentStats();
        } catch (e) {
          log("textLogs", `‚ùå Error applying ${formatType}: ${e}`, "error");
        }
      }

      // Format Button Event Listeners
      document
        .getElementById("formatBold")
        .addEventListener("click", () => applyFormatting("bold"));
      document
        .getElementById("formatItalic")
        .addEventListener("click", () => applyFormatting("italic"));
      document
        .getElementById("formatUnderline")
        .addEventListener("click", () => applyFormatting("underline"));
      document
        .getElementById("formatStrikethrough")
        .addEventListener("click", () => applyFormatting("strikethrough"));
      document
        .getElementById("formatCode")
        .addEventListener("click", () => applyFormatting("code"));
      document
        .getElementById("formatHighlight")
        .addEventListener("click", () => applyFormatting("highlight"));

      // Color Picker Event Listeners
      document.getElementById("textColor").addEventListener("change", (e) => {
        formatState.textColor = e.target.value;
        updateSelectionInfo();
      });

      document
        .getElementById("backgroundColor")
        .addEventListener("change", (e) => {
          formatState.backgroundColor = e.target.value;
          updateSelectionInfo();
        });

      // Clear Formatting
      document
        .getElementById("clearFormatting")
        .addEventListener("click", () => {
          const selection = window.getSelection();
          if (!selection.rangeCount || selection.isCollapsed) {
            log(
              "textLogs",
              "‚ö†Ô∏è Please select text to clear formatting",
              "warning",
            );
            return;
          }

          try {
            saveToUndoStack();

            const selectedText = selection.toString();
            const range = selection.getRangeAt(0);

            // Reset format state
            formatState = {
              bold: false,
              italic: false,
              underline: false,
              strikethrough: false,
              code: false,
              highlight: false,
              textColor: "#000000",
              backgroundColor: "#ffffff",
            };

            // Replace with plain text
            const textNode = document.createTextNode(selectedText);
            range.deleteContents();
            range.insertNode(textNode);

            selection.removeAllRanges();
            updateFormatButtonStates();
            updateDocumentStats();

            log(
              "textLogs",
              `üßπ Cleared formatting from "${selectedText.substring(0, 30)}..."`,
              "success",
            );
          } catch (e) {
            log("textLogs", `‚ùå Error clearing formatting: ${e}`, "error");
          }
        });

      // Undo/Redo Functionality
      document.getElementById("undoAction").addEventListener("click", () => {
        if (undoStack.length > 0 && currentDocument) {
          try {
            const currentContent = currentDocument.text_content();
            redoStack.push(currentContent);

            const previousContent = undoStack.pop();
            currentDocument.clear();

            // Split content into lines and add them back
            const lines = previousContent.split("\n");
            lines.forEach((line) => {
              if (line.trim()) {
                currentDocument.append_text(line);
              }
            });

            updateUndoRedoButtons();
            updateDocumentStats();
            log("textLogs", "‚Ü∂ Undo action performed", "info");
          } catch (e) {
            log("textLogs", `‚ùå Undo error: ${e}`, "error");
          }
        }
      });

      document.getElementById("redoAction").addEventListener("click", () => {
        if (redoStack.length > 0 && currentDocument) {
          try {
            const currentContent = currentDocument.text_content();
            undoStack.push(currentContent);

            const nextContent = redoStack.pop();
            currentDocument.clear();

            // Split content into lines and add them back
            const lines = nextContent.split("\n");
            lines.forEach((line) => {
              if (line.trim()) {
                currentDocument.append_text(line);
              }
            });

            updateUndoRedoButtons();
            updateDocumentStats();
            log("textLogs", "‚Ü∑ Redo action performed", "info");
          } catch (e) {
            log("textLogs", `‚ùå Redo error: ${e}`, "error");
          }
        }
      });

      // Keyboard Shortcuts
      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey || e.metaKey) {
          switch (e.key.toLowerCase()) {
            case "b":
              e.preventDefault();
              document.getElementById("formatBold").click();
              break;
            case "i":
              e.preventDefault();
              document.getElementById("formatItalic").click();
              break;
            case "u":
              e.preventDefault();
              document.getElementById("formatUnderline").click();
              break;
            case "z":
              e.preventDefault();
              if (e.shiftKey) {
                document.getElementById("redoAction").click();
              } else {
                document.getElementById("undoAction").click();
              }
              break;
            case "y":
              e.preventDefault();
              document.getElementById("redoAction").click();
              break;
          }
        }
      });

      // Enhanced Selection and Cursor Event Listeners
      document.addEventListener("selectionchange", updateSelectionInfo);

      // Add cursor tracking to the editor
      document.addEventListener("click", (e) => {
        if (e.target.closest("#editor")) {
          setTimeout(showCursorIndicator, 10);
        }
      });

      document.addEventListener("keyup", (e) => {
        if (e.target.closest("#editor")) {
          updateSelectionInfo();
          setTimeout(showCursorIndicator, 10);
        }
      });

      // Mouse movement tracking for selection
      let isSelecting = false;
      document.addEventListener("mousedown", (e) => {
        if (e.target.closest("#editor")) {
          isSelecting = true;
        }
      });

      document.addEventListener("mousemove", (e) => {
        if (isSelecting && e.target.closest("#editor")) {
          updateSelectionInfo();
        }
      });

      document.addEventListener("mouseup", (e) => {
        if (isSelecting) {
          isSelecting = false;
          updateSelectionInfo();
          setTimeout(showCursorIndicator, 10);
        }
      });

      // Initialize
      document
        .querySelectorAll("button")
        .forEach((btn) => (btn.disabled = true));
      document
        .querySelectorAll("input")
        .forEach((input) => (input.disabled = true));
      initializeWasm();

      // Update stats periodically
      setInterval(updateStats, 2000);
    </script>
  </body>
</html>
