<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QuillAi Parchment WASM - Interactive Editor Demo</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background: #f8f9fa;
      }

      .editor-container {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin: 20px 0;
      }

      .editor-toolbar {
        background: #f8f9fa;
        border-bottom: 1px solid #dee2e6;
        padding: 10px 15px;
        border-radius: 8px 8px 0 0;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .editor-content {
        min-height: 300px;
        padding: 20px;
        font-size: 16px;
        line-height: 1.6;
        outline: none;
      }

      .parchment-scroll {
        min-height: 250px;
        border: 1px dashed #dee2e6;
        border-radius: 4px;
        padding: 15px;
        background: #fefefe;
      }

      .btn {
        background: #007bff;
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.2s;
      }

      .btn:hover {
        background: #0056b3;
      }
      .btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }
      .btn-secondary {
        background: #6c757d;
      }
      .btn-secondary:hover {
        background: #545b62;
      }
      .btn-success {
        background: #28a745;
      }
      .btn-success:hover {
        background: #1e7e34;
      }
      .btn-danger {
        background: #dc3545;
      }
      .btn-danger:hover {
        background: #c82333;
      }

      .status-bar {
        background: #e9ecef;
        padding: 8px 15px;
        border-radius: 0 0 8px 8px;
        font-size: 12px;
        color: #6c757d;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .performance-stats {
        background: #fff;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin: 20px 0;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }

      .stat-item {
        text-align: center;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 4px;
      }

      .stat-value {
        font-size: 24px;
        font-weight: bold;
        color: #007bff;
      }

      .stat-label {
        font-size: 12px;
        color: #6c757d;
        margin-top: 5px;
      }

      .demo-text {
        background: #e3f2fd;
        border-left: 4px solid #2196f3;
        padding: 15px;
        margin: 20px 0;
        border-radius: 0 4px 4px 0;
      }

      .feature-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }

      .feature-card {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
      }

      .feature-title {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 10px;
        color: #495057;
      }

      .logs {
        background: #2d3748;
        color: #e2e8f0;
        border-radius: 4px;
        padding: 15px;
        font-family: "Consolas", "Monaco", monospace;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
        margin: 10px 0;
      }

      .log-success {
        color: #68d391;
      }
      .log-error {
        color: #f56565;
      }
      .log-warning {
        color: #f6e05e;
      }
      .log-info {
        color: #63b3ed;
      }
    </style>
  </head>
  <body>
    <h1>ü¶Ä QuillAi Parchment WASM Interactive Editor Demo</h1>
    <p>
      A full-featured demonstration of the Rust/WebAssembly Parchment rich text
      editor implementation.
    </p>

    <div class="demo-text">
      <strong>üöÄ What you're seeing:</strong> This is a live demonstration of
      QuillAi Parchment WASM running in your browser. The editor below is
      powered by Rust code compiled to WebAssembly, providing native performance
      for text manipulation operations.
    </div>

    <!-- Main Editor -->
    <div class="editor-container">
      <div class="editor-toolbar">
        <button class="btn" id="newDocument" disabled>üìÑ New</button>
        <button class="btn" id="addParagraph" disabled>‚ûï Add Paragraph</button>
        <button class="btn" id="insertText" disabled>üìù Insert Text</button>
        <button class="btn btn-secondary" id="clearDocument" disabled>
          üóëÔ∏è Clear
        </button>

        <div style="margin-left: auto; display: flex; gap: 10px">
          <button class="btn btn-success" id="saveContent" disabled>
            üíæ Save
          </button>
          <button class="btn" id="loadContent" disabled>üìÇ Load</button>
        </div>
      </div>

      <div class="editor-content">
        <div id="editor" class="parchment-scroll">
          Click "New Document" to start editing...
        </div>
      </div>

      <div class="status-bar">
        <span id="documentStats">Document: Not initialized</span>
        <span id="performanceStats">Performance: Ready</span>
      </div>
    </div>

    <!-- Performance Dashboard -->
    <div class="performance-stats">
      <h3>üìä Performance Dashboard</h3>
      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-value" id="operationsCount">0</div>
          <div class="stat-label">Total Operations</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="averageTime">0ms</div>
          <div class="stat-label">Average Operation Time</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="memoryUsage">N/A</div>
          <div class="stat-label">Memory Usage</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="wasmSize">~28KB</div>
          <div class="stat-label">WASM Bundle Size</div>
        </div>
      </div>
    </div>

    <!-- Feature Demonstrations -->
    <div class="feature-grid">
      <div class="feature-card">
        <div class="feature-title">üéØ Text Operations</div>
        <p>Test core text manipulation features</p>
        <button class="btn" id="demoInsert" disabled>Insert Demo</button>
        <button class="btn" id="demoDelete" disabled>Delete Demo</button>
        <button class="btn" id="demoSplit" disabled>Split Demo</button>
        <div class="logs" id="textLogs">
          Text operation logs will appear here...
        </div>
      </div>

      <div class="feature-card">
        <div class="feature-title">üèóÔ∏è Document Structure</div>
        <p>Explore document tree operations</p>
        <button class="btn" id="inspectDocument" disabled>Inspect</button>
        <button class="btn" id="buildComplex" disabled>Build Complex</button>
        <button class="btn" id="extractContent" disabled>Extract</button>
        <div class="logs" id="structureLogs">
          Structure logs will appear here...
        </div>
      </div>

      <div class="feature-card">
        <div class="feature-title">‚ö° Performance Testing</div>
        <p>Benchmark WASM performance</p>
        <button class="btn" id="benchmarkBasic" disabled>
          Basic Benchmark
        </button>
        <button class="btn" id="benchmarkComplex" disabled>
          Complex Benchmark
        </button>
        <button class="btn" id="stressTesting" disabled>Stress Test</button>
        <div class="logs" id="performanceLogs">
          Performance logs will appear here...
        </div>
      </div>

      <div class="feature-card">
        <div class="feature-title">üîß DOM Integration</div>
        <p>Test browser DOM interaction</p>
        <button class="btn" id="domManipulation" disabled>
          DOM Manipulation
        </button>
        <button class="btn" id="eventHandling" disabled>Event Handling</button>
        <button class="btn" id="cssIntegration" disabled>
          CSS Integration
        </button>
        <div class="logs" id="domLogs">DOM logs will appear here...</div>
      </div>
    </div>

    <script type="module">
      let wasmModule;
      let currentDocument = null;
      let operationStats = {
        count: 0,
        totalTime: 0,
        operations: [],
      };

      async function initializeWasm() {
        try {
          updateStatus("Loading WASM module...");
          wasmModule = await import("../pkg/quillai_parchment.js");
          await wasmModule.default();
          wasmModule.init_panic_hook();

          updateStatus("WASM loaded successfully");
          enableInterface();
          updateStats();

          log(
            "performanceLogs",
            "‚úÖ WASM module initialized successfully",
            "success",
          );
        } catch (error) {
          updateStatus(`Error: ${error.message}`);
          log(
            "performanceLogs",
            `‚ùå Failed to initialize WASM: ${error}`,
            "error",
          );
          console.error("WASM initialization failed:", error);
        }
      }

      function enableInterface() {
        document
          .querySelectorAll("button")
          .forEach((btn) => (btn.disabled = false));
      }

      function updateStatus(message) {
        document.getElementById("performanceStats").textContent = message;
      }

      function updateStats() {
        document.getElementById("operationsCount").textContent =
          operationStats.count;
        document.getElementById("averageTime").textContent =
          operationStats.count > 0
            ? `${(operationStats.totalTime / operationStats.count).toFixed(2)}ms`
            : "0ms";

        if (performance.memory) {
          const memory = (
            performance.memory.usedJSHeapSize /
            1024 /
            1024
          ).toFixed(1);
          document.getElementById("memoryUsage").textContent = `${memory}MB`;
        }
      }

      function measureOperation(name, operation) {
        const start = performance.now();
        const result = operation();
        const end = performance.now();
        const duration = end - start;

        operationStats.count++;
        operationStats.totalTime += duration;
        operationStats.operations.push({
          name,
          duration,
          timestamp: Date.now(),
        });

        updateStats();
        return result;
      }

      function updateDocumentStats() {
        if (!currentDocument) {
          document.getElementById("documentStats").textContent =
            "Document: Not initialized";
          return;
        }

        try {
          const children = currentDocument.children_count();
          const isEmpty = currentDocument.is_empty();
          const textLength = currentDocument.text_content().length;

          document.getElementById("documentStats").textContent =
            `Document: ${children} children, ${textLength} chars, ${isEmpty ? "empty" : "has content"}`;
        } catch (e) {
          document.getElementById("documentStats").textContent =
            `Document: Error - ${e.message}`;
        }
      }

      function log(containerId, message, type = "info") {
        const container = document.getElementById(containerId);
        const timestamp = new Date().toLocaleTimeString();
        const className = `log-${type}`;

        container.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
        container.scrollTop = container.scrollHeight;
      }

      // Main Editor Functions
      document.getElementById("newDocument").addEventListener("click", () => {
        try {
          if (currentDocument) {
            currentDocument.free();
          }

          currentDocument = measureOperation("Create Document", () => {
            return new wasmModule.ScrollBlot();
          });

          const editorElement = document.getElementById("editor");
          editorElement.innerHTML = "";

          const scrollElement = currentDocument.dom_element();
          editorElement.appendChild(scrollElement);

          updateDocumentStats();
          updateStatus("New document created");
          log(
            "structureLogs",
            "üìÑ New document created successfully",
            "success",
          );
        } catch (e) {
          log("structureLogs", `‚ùå Error creating document: ${e}`, "error");
        }
      });

      document.getElementById("addParagraph").addEventListener("click", () => {
        if (!currentDocument) {
          log("textLogs", "‚ö†Ô∏è  Please create a document first", "warning");
          return;
        }

        try {
          const paragraphs = [
            "This paragraph was created with Rust and compiled to WebAssembly! ü¶Ä",
            "QuillAi Parchment WASM provides native performance for rich text editing operations. ‚ö°",
            "The entire text processing pipeline runs in WebAssembly for maximum speed. üöÄ",
            "Complex document structures are handled efficiently with minimal overhead. üèóÔ∏è",
            "Real-time editing with sub-millisecond response times! ‚è±Ô∏è",
          ];

          const randomParagraph =
            paragraphs[Math.floor(Math.random() * paragraphs.length)];

          measureOperation("Add Paragraph", () => {
            currentDocument.append_text(randomParagraph);
          });

          updateDocumentStats();
          log(
            "textLogs",
            `‚úÖ Added paragraph: "${randomParagraph.substring(0, 50)}..."`,
            "success",
          );
        } catch (e) {
          log("textLogs", `‚ùå Error adding paragraph: ${e}`, "error");
        }
      });

      document.getElementById("insertText").addEventListener("click", () => {
        if (!currentDocument) {
          log("textLogs", "‚ö†Ô∏è  Please create a document first", "warning");
          return;
        }

        try {
          const insertTexts = [
            "üî• INSERTED: Hot new content!",
            "‚≠ê INSERTED: Stellar performance!",
            "üíé INSERTED: Premium quality text!",
            "üéØ INSERTED: Precision insertion!",
            "üåü INSERTED: Brilliant addition!",
          ];

          const randomText =
            insertTexts[Math.floor(Math.random() * insertTexts.length)];

          measureOperation("Insert Text", () => {
            currentDocument.insert_text_at(0, randomText);
          });

          updateDocumentStats();
          log("textLogs", `‚úÖ Inserted text: "${randomText}"`, "success");
        } catch (e) {
          log("textLogs", `‚ùå Error inserting text: ${e}`, "error");
        }
      });

      document.getElementById("clearDocument").addEventListener("click", () => {
        if (!currentDocument) {
          log("structureLogs", "‚ö†Ô∏è  No document to clear", "warning");
          return;
        }

        try {
          measureOperation("Clear Document", () => {
            currentDocument.clear();
          });

          updateDocumentStats();
          log("structureLogs", "üóëÔ∏è Document cleared successfully", "success");
        } catch (e) {
          log("structureLogs", `‚ùå Error clearing document: ${e}`, "error");
        }
      });

      document.getElementById("saveContent").addEventListener("click", () => {
        if (!currentDocument) {
          log("domLogs", "‚ö†Ô∏è  No document to save", "warning");
          return;
        }

        try {
          const content = currentDocument.text_content();
          const blob = new Blob([content], { type: "text/plain" });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = `parchment-document-${Date.now()}.txt`;
          a.click();

          URL.revokeObjectURL(url);
          log(
            "domLogs",
            `üíæ Document saved (${content.length} characters)`,
            "success",
          );
        } catch (e) {
          log("domLogs", `‚ùå Error saving document: ${e}`, "error");
        }
      });

      document.getElementById("loadContent").addEventListener("click", () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".txt";

        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              if (!currentDocument) {
                document.getElementById("newDocument").click();
              }

              currentDocument.clear();

              const content = e.target.result;
              const lines = content.split("\n");

              lines.forEach((line) => {
                if (line.trim()) {
                  currentDocument.append_text(line);
                }
              });

              updateDocumentStats();
              log(
                "domLogs",
                `üìÇ Loaded document (${lines.length} lines)`,
                "success",
              );
            } catch (e) {
              log("domLogs", `‚ùå Error loading document: ${e}`, "error");
            }
          };
          reader.readAsText(file);
        };

        input.click();
      });

      // Feature Demonstration Functions
      document.getElementById("demoInsert").addEventListener("click", () => {
        try {
          const textBlot = new wasmModule.TextBlot("Original text content");

          const operations = [
            () => textBlot.insert_at(0, "üî¥ START: "),
            () => textBlot.insert_at(textBlot.length(), " :END üî¥"),
            () => textBlot.insert_at(8, " üîµ MIDDLE üîµ "),
          ];

          operations.forEach((op, i) => {
            measureOperation(`Insert Demo ${i + 1}`, op);
            log("textLogs", `‚úÖ Step ${i + 1}: "${textBlot.value()}"`, "info");
          });

          textBlot.free();
          log("textLogs", "üéØ Insert demonstration completed", "success");
        } catch (e) {
          log("textLogs", `‚ùå Insert demo error: ${e}`, "error");
        }
      });

      document.getElementById("demoDelete").addEventListener("click", () => {
        try {
          const textBlot = new wasmModule.TextBlot(
            "This is a demonstration of text deletion capabilities in QuillAi Parchment WASM! ü¶ÄüöÄ‚ö°",
          );
          log("textLogs", `üìù Initial: "${textBlot.value()}"`, "info");

          const operations = [
            () => textBlot.delete_at(0, 5), // Remove "This "
            () => textBlot.delete_at(textBlot.length() - 10, 10), // Remove emojis
            () => textBlot.delete_at(10, 20), // Remove middle part
          ];

          operations.forEach((op, i) => {
            measureOperation(`Delete Demo ${i + 1}`, op);
            log("textLogs", `‚úÖ Step ${i + 1}: "${textBlot.value()}"`, "info");
          });

          textBlot.free();
          log("textLogs", "üéØ Delete demonstration completed", "success");
        } catch (e) {
          log("textLogs", `‚ùå Delete demo error: ${e}`, "error");
        }
      });

      document.getElementById("demoSplit").addEventListener("click", () => {
        try {
          const textBlot = new wasmModule.TextBlot(
            "Split this text into multiple parts using WASM power! üî•",
          );
          log("textLogs", `üìù Original: "${textBlot.value()}"`, "info");

          const parts = [];
          let currentBlot = textBlot;

          for (let i = 0; i < 3; i++) {
            if (currentBlot.length() > 10) {
              const splitPoint = Math.floor(currentBlot.length() / 2);
              const newPart = measureOperation(`Split Demo ${i + 1}`, () => {
                return currentBlot.split(splitPoint);
              });

              log(
                "textLogs",
                `‚úÇÔ∏è  Part ${i + 1}: "${currentBlot.value()}"`,
                "info",
              );
              log(
                "textLogs",
                `‚úÇÔ∏è  Part ${i + 2}: "${newPart.value()}"`,
                "info",
              );

              parts.push(newPart);
              if (i < 2) currentBlot = newPart;
            }
          }

          // Cleanup
          textBlot.free();
          parts.forEach((part) => part.free());

          log("textLogs", "üéØ Split demonstration completed", "success");
        } catch (e) {
          log("textLogs", `‚ùå Split demo error: ${e}`, "error");
        }
      });

      document
        .getElementById("inspectDocument")
        .addEventListener("click", () => {
          if (!currentDocument) {
            log("structureLogs", "‚ö†Ô∏è  No document to inspect", "warning");
            return;
          }

          try {
            const stats = {
              children: currentDocument.children_count(),
              isEmpty: currentDocument.is_empty(),
              textContent: currentDocument.text_content(),
              domElement: currentDocument.dom_element(),
              length: currentDocument.length(),
            };

            log("structureLogs", "üîç Document Inspection Results:", "info");
            log("structureLogs", `   Children: ${stats.children}`, "info");
            log("structureLogs", `   Empty: ${stats.isEmpty}`, "info");
            log(
              "structureLogs",
              `   Text Length: ${stats.textContent.length}`,
              "info",
            );
            log(
              "structureLogs",
              `   DOM Tag: ${stats.domElement.tagName}`,
              "info",
            );
            log(
              "structureLogs",
              `   DOM Class: ${stats.domElement.className}`,
              "info",
            );
            log(
              "structureLogs",
              `   Content Preview: "${stats.textContent.substring(0, 100)}${stats.textContent.length > 100 ? "..." : ""}"`,
              "info",
            );
          } catch (e) {
            log("structureLogs", `‚ùå Inspection error: ${e}`, "error");
          }
        });

      document.getElementById("buildComplex").addEventListener("click", () => {
        try {
          if (!currentDocument) {
            document.getElementById("newDocument").click();
          }

          currentDocument.clear();

          const complexContent = [
            "üìö Chapter 1: Introduction to QuillAi Parchment WASM",
            "This chapter introduces the fundamental concepts of rich text editing with WebAssembly.",
            "",
            "üîß Chapter 2: Technical Implementation",
            "We explore the Rust implementation details and performance characteristics.",
            "",
            "‚ö° Chapter 3: Performance Optimization",
            "Advanced techniques for maximizing text processing speed.",
            "",
            "üéØ Chapter 4: Real-world Applications",
            "Case studies and practical deployment scenarios.",
            "",
            "üöÄ Conclusion",
            "QuillAi Parchment WASM represents the future of web-based text editing!",
          ];

          complexContent.forEach((text, i) => {
            measureOperation(`Complex Build ${i + 1}`, () => {
              currentDocument.append_text(text);
            });
          });

          updateDocumentStats();
          log(
            "structureLogs",
            `üèóÔ∏è Built complex document with ${complexContent.length} sections`,
            "success",
          );
        } catch (e) {
          log("structureLogs", `‚ùå Complex build error: ${e}`, "error");
        }
      });

      document
        .getElementById("extractContent")
        .addEventListener("click", () => {
          if (!currentDocument) {
            log("structureLogs", "‚ö†Ô∏è  No document to extract from", "warning");
            return;
          }

          try {
            const textContent = currentDocument.text_content();
            const domElement = currentDocument.dom_element();

            const analysis = {
              totalChars: textContent.length,
              words: textContent.split(/\s+/).filter((w) => w.length > 0)
                .length,
              lines: textContent.split("\n").length,
              domChildren: domElement.childNodes.length,
              htmlLength: domElement.innerHTML.length,
            };

            log("structureLogs", "üì§ Content Extraction Results:", "success");
            log(
              "structureLogs",
              `   Total Characters: ${analysis.totalChars}`,
              "info",
            );
            log("structureLogs", `   Word Count: ${analysis.words}`, "info");
            log("structureLogs", `   Line Count: ${analysis.lines}`, "info");
            log(
              "structureLogs",
              `   DOM Children: ${analysis.domChildren}`,
              "info",
            );
            log(
              "structureLogs",
              `   HTML Length: ${analysis.htmlLength}`,
              "info",
            );
          } catch (e) {
            log("structureLogs", `‚ùå Extraction error: ${e}`, "error");
          }
        });

      document
        .getElementById("benchmarkBasic")
        .addEventListener("click", () => {
          try {
            const iterations = 1000;
            log(
              "performanceLogs",
              `üèÉ‚Äç‚ôÇÔ∏è Starting basic benchmark (${iterations} operations)...`,
              "info",
            );

            const start = performance.now();
            const blots = [];

            for (let i = 0; i < iterations; i++) {
              const blot = new wasmModule.TextBlot(`Benchmark text ${i}`);
              blot.insert_at(0, "üî• ");
              blots.push(blot);
            }

            const middle = performance.now();

            blots.forEach((blot) => blot.free());

            const end = performance.now();

            const createTime = middle - start;
            const cleanupTime = end - middle;
            const totalTime = end - start;

            log("performanceLogs", `‚úÖ Benchmark Results:`, "success");
            log(
              "performanceLogs",
              `   Creation: ${createTime.toFixed(2)}ms (${(createTime / iterations).toFixed(4)}ms each)`,
              "info",
            );
            log(
              "performanceLogs",
              `   Cleanup: ${cleanupTime.toFixed(2)}ms (${(cleanupTime / iterations).toFixed(4)}ms each)`,
              "info",
            );
            log(
              "performanceLogs",
              `   Total: ${totalTime.toFixed(2)}ms`,
              "info",
            );
            log(
              "performanceLogs",
              `   Operations/sec: ${(iterations / (totalTime / 1000)).toFixed(0)}`,
              "info",
            );
          } catch (e) {
            log("performanceLogs", `‚ùå Benchmark error: ${e}`, "error");
          }
        });

      document
        .getElementById("benchmarkComplex")
        .addEventListener("click", () => {
          try {
            log("performanceLogs", "üî• Starting complex benchmark...", "info");

            const start = performance.now();
            const scroll = new wasmModule.ScrollBlot();

            // Complex operations
            for (let i = 0; i < 100; i++) {
              scroll.append_text(
                `Complex paragraph ${i} with various operations and longer content to test performance under realistic conditions.`,
              );
            }

            const textBlot = new wasmModule.TextBlot(
              "Complex manipulation test content with emoji ü¶ÄüöÄ‚ö°üî•üíØ",
            );
            for (let i = 0; i < 500; i++) {
              textBlot.insert_at(0, `${i % 10} `);
              if (i % 50 === 0 && textBlot.length() > 100) {
                const split = textBlot.split(textBlot.length() / 2);
                split.free();
              }
              if (i % 25 === 0 && textBlot.length() > 50) {
                textBlot.delete_at(10, 5);
              }
            }

            const end = performance.now();
            const duration = end - start;

            log("performanceLogs", `‚úÖ Complex Benchmark Results:`, "success");
            log(
              "performanceLogs",
              `   Total time: ${duration.toFixed(2)}ms`,
              "info",
            );
            log("performanceLogs", `   Operations completed: ~650`, "info");
            log(
              "performanceLogs",
              `   ScrollBlot children: ${scroll.children_count()}`,
              "info",
            );
            log(
              "performanceLogs",
              `   TextBlot final length: ${textBlot.length()}`,
              "info",
            );
            log(
              "performanceLogs",
              `   Average per operation: ${(duration / 650).toFixed(4)}ms`,
              "info",
            );

            scroll.free();
            textBlot.free();
          } catch (e) {
            log("performanceLogs", `‚ùå Complex benchmark error: ${e}`, "error");
          }
        });

      document.getElementById("stressTesting").addEventListener("click", () => {
        try {
          log("performanceLogs", "üí™ Starting stress test...", "warning");

          const start = performance.now();
          const objects = [];

          // Create many objects
          for (let i = 0; i < 2000; i++) {
            if (i % 2 === 0) {
              objects.push(new wasmModule.TextBlot(`Stress test ${i}`));
            } else {
              objects.push(new wasmModule.ScrollBlot());
            }

            if (i % 100 === 0) {
              log("performanceLogs", `   Created ${i + 1} objects...`, "info");
            }
          }

          const middle = performance.now();

          // Perform operations
          objects.forEach((obj, i) => {
            if (obj.constructor.name === "TextBlot") {
              obj.insert_at(0, "üî•");
              if (obj.length() > 20) {
                obj.delete_at(5, 5);
              }
            } else {
              obj.append_text(`Stress content ${i}`);
            }
          });

          const operations = performance.now();

          // Cleanup
          objects.forEach((obj) => obj.free());

          const end = performance.now();

          log("performanceLogs", `üí™ Stress Test Results:`, "success");
          log(
            "performanceLogs",
            `   Creation: ${(middle - start).toFixed(2)}ms`,
            "info",
          );
          log(
            "performanceLogs",
            `   Operations: ${(operations - middle).toFixed(2)}ms`,
            "info",
          );
          log(
            "performanceLogs",
            `   Cleanup: ${(end - operations).toFixed(2)}ms`,
            "info",
          );
          log(
            "performanceLogs",
            `   Total: ${(end - start).toFixed(2)}ms for 2000 objects`,
            "info",
          );
          log("performanceLogs", `   Memory seems stable! üéâ`, "success");
        } catch (e) {
          log("performanceLogs", `‚ùå Stress test error: ${e}`, "error");
        }
      });

      document
        .getElementById("domManipulation")
        .addEventListener("click", () => {
          try {
            const scrollBlot = new wasmModule.ScrollBlot();
            const domElement = scrollBlot.dom_element();

            // Style the element
            domElement.style.border = "2px solid #007bff";
            domElement.style.borderRadius = "8px";
            domElement.style.padding = "15px";
            domElement.style.background =
              "linear-gradient(45deg, #e3f2fd, #f3e5f5)";
            domElement.style.transition = "all 0.3s ease";

            // Add content
            scrollBlot.append_text(
              "üé® This element has been styled via DOM manipulation!",
            );
            scrollBlot.append_text(
              "üîß Background gradient applied through JavaScript!",
            );
            scrollBlot.append_text("‚ú® Smooth transitions and modern styling!");

            // Create a temporary container
            const container = document.createElement("div");
            container.style.margin = "10px 0";
            container.appendChild(domElement);

            const logs = document.getElementById("domLogs");
            logs.parentNode.insertBefore(container, logs);

            // Animate
            setTimeout(() => {
              domElement.style.transform = "scale(1.05)";
              domElement.style.boxShadow = "0 5px 15px rgba(0,123,255,0.3)";
            }, 100);

            setTimeout(() => {
              domElement.style.transform = "scale(1)";
              container.remove();
              scrollBlot.free();
            }, 3000);

            log("domLogs", "üé® DOM manipulation demo completed", "success");
            log(
              "domLogs",
              "   Applied styles, gradients, and animations",
              "info",
            );
            log("domLogs", "   Element will be removed automatically", "info");
          } catch (e) {
            log("domLogs", `‚ùå DOM manipulation error: ${e}`, "error");
          }
        });

      document.getElementById("eventHandling").addEventListener("click", () => {
        try {
          const scrollBlot = new wasmModule.ScrollBlot();
          const domElement = scrollBlot.dom_element();

          domElement.style.border = "2px dashed #28a745";
          domElement.style.padding = "20px";
          domElement.style.cursor = "pointer";
          domElement.style.userSelect = "none";

          scrollBlot.append_text("üñ±Ô∏è Click me! I'm interactive!");
          scrollBlot.append_text("üëÜ Hover to see effects!");

          let clickCount = 0;

          domElement.addEventListener("click", () => {
            clickCount++;
            domElement.style.background = `hsl(${clickCount * 30}, 70%, 90%)`;
            log("domLogs", `üñ±Ô∏è Element clicked ${clickCount} times`, "info");
          });

          domElement.addEventListener("mouseenter", () => {
            domElement.style.transform = "scale(1.02)";
            domElement.style.boxShadow = "0 3px 10px rgba(40,167,69,0.3)";
          });

          domElement.addEventListener("mouseleave", () => {
            domElement.style.transform = "scale(1)";
            domElement.style.boxShadow = "none";
          });

          const container = document.createElement("div");
          container.style.margin = "10px 0";
          container.appendChild(domElement);

          const logs = document.getElementById("domLogs");
          logs.parentNode.insertBefore(container, logs);

          setTimeout(() => {
            container.remove();
            scrollBlot.free();
          }, 10000);

          log(
            "domLogs",
            "üéØ Event handling demo active for 10 seconds",
            "success",
          );
          log("domLogs", "   Click and hover the element above!", "info");
        } catch (e) {
          log("domLogs", `‚ùå Event handling error: ${e}`, "error");
        }
      });

      document
        .getElementById("cssIntegration")
        .addEventListener("click", () => {
          try {
            const scrollBlot = new wasmModule.ScrollBlot();
            const domElement = scrollBlot.dom_element();

            // Add CSS classes
            domElement.classList.add("animated-element");
            domElement.dataset.demo = "css-integration";

            // Create dynamic CSS
            const style = document.createElement("style");
            style.textContent = `
                    .animated-element {
                        border: 3px solid #dc3545;
                        border-radius: 12px;
                        padding: 20px;
                        background: linear-gradient(270deg, #ffeaa7, #fab1a0, #fd79a8);
                        background-size: 600% 600%;
                        animation: gradientShift 3s ease infinite;
                        font-weight: bold;
                        color: #2d3436;
                    }

                    @keyframes gradientShift {
                        0% { background-position: 0% 50%; }
                        50% { background-position: 100% 50%; }
                        100% { background-position: 0% 50%; }
                    }

                    .animated-element:hover {
                        animation-duration: 1s;
                        transform: translateY(-2px);
                        box-shadow: 0 10px 20px rgba(220,53,69,0.3);
                    }
                `;
            document.head.appendChild(style);

            scrollBlot.append_text("üåà CSS Animation Integration!");
            scrollBlot.append_text("üí´ Gradient animations with WASM content!");
            scrollBlot.append_text("üé™ Hover for accelerated effects!");

            const container = document.createElement("div");
            container.style.margin = "15px 0";
            container.appendChild(domElement);

            const logs = document.getElementById("domLogs");
            logs.parentNode.insertBefore(container, logs);

            setTimeout(() => {
              container.remove();
              document.head.removeChild(style);
              scrollBlot.free();
            }, 8000);

            log(
              "domLogs",
              "üåà CSS integration demo running for 8 seconds",
              "success",
            );
            log(
              "domLogs",
              "   Dynamic CSS animations with WASM content",
              "info",
            );
            log(
              "domLogs",
              "   Hover effects and gradient animations active",
              "info",
            );
          } catch (e) {
            log("domLogs", `‚ùå CSS integration error: ${e}`, "error");
          }
        });

      // Initialize
      document
        .querySelectorAll("button")
        .forEach((btn) => (btn.disabled = true));
      initializeWasm();

      // Update stats periodically
      setInterval(updateStats, 2000);
    </script>
  </body>
</html>
